define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./Transforms-51e2663f","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./RuntimeError-8952249c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./VertexFormat-a0b706b0","./WallGeometryLibrary-2f7b98cd","./Matrix2-115e2170","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./arrayRemoveDuplicates-4bbe2c1f","./PolylinePipeline-cfd2c1cf","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271","./IntersectionTests-4511d2eb","./Plane-f0451b7c"],(function(e,t,n,i,a,o,r,s,l,m,c,u,p,d,f,y,g,h,b,C,x,A){"use strict";const _=new i.Cartesian3,E=new i.Cartesian3,w=new i.Cartesian3,F=new i.Cartesian3,v=new i.Cartesian3,L=new i.Cartesian3,H=new i.Cartesian3;function V(n){const a=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,o=n.maximumHeights,r=n.minimumHeights,s=e.defaultValue(n.vertexFormat,c.VertexFormat.DEFAULT),l=e.defaultValue(n.granularity,m.CesiumMath.RADIANS_PER_DEGREE),u=e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84);this._positions=a,this._minimumHeights=r,this._maximumHeights=o,this._vertexFormat=c.VertexFormat.clone(s),this._granularity=l,this._ellipsoid=t.Ellipsoid.clone(u),this._workerName="createWallGeometry";let p=1+a.length*i.Cartesian3.packedLength+2;e.defined(r)&&(p+=r.length),e.defined(o)&&(p+=o.length),this.packedLength=p+t.Ellipsoid.packedLength+c.VertexFormat.packedLength+1}V.pack=function(n,a,o){let r;o=e.defaultValue(o,0);const s=n._positions;let l=s.length;for(a[o++]=l,r=0;r<l;++r,o+=i.Cartesian3.packedLength)i.Cartesian3.pack(s[r],a,o);const m=n._minimumHeights;if(l=e.defined(m)?m.length:0,a[o++]=l,e.defined(m))for(r=0;r<l;++r)a[o++]=m[r];const u=n._maximumHeights;if(l=e.defined(u)?u.length:0,a[o++]=l,e.defined(u))for(r=0;r<l;++r)a[o++]=u[r];return t.Ellipsoid.pack(n._ellipsoid,a,o),o+=t.Ellipsoid.packedLength,c.VertexFormat.pack(n._vertexFormat,a,o),a[o+=c.VertexFormat.packedLength]=n._granularity,a};const k=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),G=new c.VertexFormat,D={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:k,vertexFormat:G,granularity:void 0};return V.unpack=function(n,a,o){let r;a=e.defaultValue(a,0);let s=n[a++];const l=new Array(s);for(r=0;r<s;++r,a+=i.Cartesian3.packedLength)l[r]=i.Cartesian3.unpack(n,a);let m,u;if(s=n[a++],s>0)for(m=new Array(s),r=0;r<s;++r)m[r]=n[a++];if(s=n[a++],s>0)for(u=new Array(s),r=0;r<s;++r)u[r]=n[a++];const p=t.Ellipsoid.unpack(n,a,k);a+=t.Ellipsoid.packedLength;const d=c.VertexFormat.unpack(n,a,G),f=n[a+=c.VertexFormat.packedLength];return e.defined(o)?(o._positions=l,o._minimumHeights=m,o._maximumHeights=u,o._ellipsoid=t.Ellipsoid.clone(p,o._ellipsoid),o._vertexFormat=c.VertexFormat.clone(d,o._vertexFormat),o._granularity=f,o):(D.positions=l,D.minimumHeights=m,D.maximumHeights=u,D.granularity=f,new V(D))},V.fromConstantHeights=function(t){const n=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;let i,a;const o=t.minimumHeight,r=t.maximumHeight,s=e.defined(o),l=e.defined(r);if(s||l){const e=n.length;i=s?new Array(e):void 0,a=l?new Array(e):void 0;for(let t=0;t<e;++t)s&&(i[t]=o),l&&(a[t]=r)}return new V({positions:n,maximumHeights:a,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},V.createGeometry=function(t){const o=t._positions,c=t._minimumHeights,p=t._maximumHeights,d=t._vertexFormat,f=t._granularity,y=t._ellipsoid,g=u.WallGeometryLibrary.computePositions(y,o,p,c,f,!0);if(!e.defined(g))return;const h=g.bottomPositions,b=g.topPositions,C=g.numCorners;let x=b.length,A=2*x;const V=d.position?new Float64Array(A):void 0,k=d.normal?new Float32Array(A):void 0,G=d.tangent?new Float32Array(A):void 0,D=d.bitangent?new Float32Array(A):void 0,P=d.st?new Float32Array(A/3*2):void 0;let T,z=0,O=0,R=0,S=0,I=0,M=H,N=L,W=v,B=!0;x/=3;let U=0;const q=1/(x-C-1);for(T=0;T<x;++T){const e=3*T,t=i.Cartesian3.fromArray(b,e,_),n=i.Cartesian3.fromArray(h,e,E);if(d.position&&(V[z++]=n.x,V[z++]=n.y,V[z++]=n.z,V[z++]=t.x,V[z++]=t.y,V[z++]=t.z),d.st&&(P[I++]=U,P[I++]=0,P[I++]=U,P[I++]=1),d.normal||d.tangent||d.bitangent){let n=i.Cartesian3.clone(i.Cartesian3.ZERO,F);const a=i.Cartesian3.subtract(t,y.geodeticSurfaceNormal(t,E),E);if(T+1<x&&(n=i.Cartesian3.fromArray(b,e+3,F)),B){const e=i.Cartesian3.subtract(n,t,w),o=i.Cartesian3.subtract(a,t,_);M=i.Cartesian3.normalize(i.Cartesian3.cross(o,e,M),M),B=!1}i.Cartesian3.equalsEpsilon(t,n,m.CesiumMath.EPSILON10)?B=!0:(U+=q,d.tangent&&(N=i.Cartesian3.normalize(i.Cartesian3.subtract(n,t,N),N)),d.bitangent&&(W=i.Cartesian3.normalize(i.Cartesian3.cross(M,N,W),W))),d.normal&&(k[O++]=M.x,k[O++]=M.y,k[O++]=M.z,k[O++]=M.x,k[O++]=M.y,k[O++]=M.z),d.tangent&&(G[S++]=N.x,G[S++]=N.y,G[S++]=N.z,G[S++]=N.x,G[S++]=N.y,G[S++]=N.z),d.bitangent&&(D[R++]=W.x,D[R++]=W.y,D[R++]=W.z,D[R++]=W.x,D[R++]=W.y,D[R++]=W.z)}}const J=new s.GeometryAttributes;d.position&&(J.position=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:V})),d.normal&&(J.normal=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),d.tangent&&(J.tangent=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),d.bitangent&&(J.bitangent=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),d.st&&(J.st=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:P}));const Y=A/3;A-=6*(C+1);const j=l.IndexDatatype.createTypedArray(Y,A);let Z=0;for(T=0;T<Y-2;T+=2){const e=T,t=T+2,n=i.Cartesian3.fromArray(V,3*e,_),a=i.Cartesian3.fromArray(V,3*t,E);if(i.Cartesian3.equalsEpsilon(n,a,m.CesiumMath.EPSILON10))continue;const o=T+1,r=T+3;j[Z++]=o,j[Z++]=e,j[Z++]=r,j[Z++]=r,j[Z++]=e,j[Z++]=t}return new r.Geometry({attributes:J,indices:j,primitiveType:r.PrimitiveType.TRIANGLES,boundingSphere:new n.BoundingSphere.fromVertices(V)})},function(n,i){return e.defined(i)&&(n=V.unpack(n,i)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),V.createGeometry(n)}}));
