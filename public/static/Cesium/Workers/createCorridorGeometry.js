define(["./GeometryOffsetAttribute-8c5e10db","./arrayRemoveDuplicates-4bbe2c1f","./Transforms-51e2663f","./Matrix4-3b2c0630","./Ellipsoid-119327cb","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./PolylineVolumeGeometryLibrary-e2c85c62","./CorridorGeometryLibrary-1dff5950","./defaultValue-81eec7ed","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonPipeline-ef9e08dd","./Matrix2-115e2170","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-6354c9aa","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./PolylinePipeline-cfd2c1cf","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271"],(function(t,e,r,a,i,o,n,s,l,d,u,c,m,f,y,p,g,h,b,C,A,_,w,v,T,G,E){"use strict";const V=new a.Cartesian3,x=new a.Cartesian3,F=new a.Cartesian3,L=new a.Cartesian3,P=new a.Cartesian3,N=new a.Cartesian3,M=new a.Cartesian3,D=new a.Cartesian3;function O(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function I(t,e,r,i,o,n){const s=t.normals,d=t.tangents,u=t.bitangents,c=a.Cartesian3.normalize(a.Cartesian3.cross(r,e,M),M);n.normal&&l.CorridorGeometryLibrary.addAttribute(s,e,i,o),n.tangent&&l.CorridorGeometryLibrary.addAttribute(d,c,i,o),n.bitangent&&l.CorridorGeometryLibrary.addAttribute(u,r,i,o)}function S(t,e,r){const i=t.positions,o=t.corners,s=t.endPositions,y=t.lefts,p=t.normals,g=new c.GeometryAttributes;let h,b,C,A=0,_=0,w=0;for(b=0;b<i.length;b+=2)C=i[b].length-3,A+=C,w+=2*C,_+=i[b+1].length-3;for(A+=3,_+=3,b=0;b<o.length;b++){h=o[b];const t=o[b].leftPositions;d.defined(t)?(C=t.length,A+=C,w+=C):(C=o[b].rightPositions.length,_+=C,w+=C)}const v=d.defined(s);let T;v&&(T=s[0].length-3,A+=T,_+=T,T/=3,w+=6*T);const G=A+_,E=new Float64Array(G),P={normals:e.normal?new Float32Array(G):void 0,tangents:e.tangent?new Float32Array(G):void 0,bitangents:e.bitangent?new Float32Array(G):void 0};let O,S,R,k,H,z,B=0,U=G-1,Y=V,W=x;const q=T/2,j=m.IndexDatatype.createTypedArray(G/3,w);let J=0;if(v){z=F,H=L;const t=s[0];for(Y=a.Cartesian3.fromArray(p,0,Y),W=a.Cartesian3.fromArray(y,0,W),b=0;b<q;b++)z=a.Cartesian3.fromArray(t,3*(q-1-b),z),H=a.Cartesian3.fromArray(t,3*(q+b),H),l.CorridorGeometryLibrary.addAttribute(E,H,B),l.CorridorGeometryLibrary.addAttribute(E,z,void 0,U),I(P,Y,W,B,U,e),S=B/3,k=S+1,O=(U-2)/3,R=O-1,j[J++]=O,j[J++]=S,j[J++]=R,j[J++]=R,j[J++]=S,j[J++]=k,B+=3,U-=3}let K,Q,X=0,Z=0,$=i[X++],tt=i[X++];for(E.set($,B),E.set(tt,U-tt.length+1),W=a.Cartesian3.fromArray(y,Z,W),C=tt.length-3,b=0;b<C;b+=3)K=r.geodeticSurfaceNormal(a.Cartesian3.fromArray($,b,M),M),Q=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(tt,C-b,D),D),Y=a.Cartesian3.normalize(a.Cartesian3.add(K,Q,Y),Y),I(P,Y,W,B,U,e),S=B/3,k=S+1,O=(U-2)/3,R=O-1,j[J++]=O,j[J++]=S,j[J++]=R,j[J++]=R,j[J++]=S,j[J++]=k,B+=3,U-=3;for(K=r.geodeticSurfaceNormal(a.Cartesian3.fromArray($,C,M),M),Q=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(tt,C,D),D),Y=a.Cartesian3.normalize(a.Cartesian3.add(K,Q,Y),Y),Z+=3,b=0;b<o.length;b++){let t;h=o[b];const n=h.leftPositions,s=h.rightPositions;let u,c,m=N,f=F,g=L;if(Y=a.Cartesian3.fromArray(p,Z,Y),d.defined(n)){for(I(P,Y,W,void 0,U,e),U-=3,u=k,c=R,t=0;t<n.length/3;t++)m=a.Cartesian3.fromArray(n,3*t,m),j[J++]=u,j[J++]=c-t-1,j[J++]=c-t,l.CorridorGeometryLibrary.addAttribute(E,m,void 0,U),f=a.Cartesian3.fromArray(E,3*(c-t-1),f),g=a.Cartesian3.fromArray(E,3*u,g),W=a.Cartesian3.normalize(a.Cartesian3.subtract(f,g,W),W),I(P,Y,W,void 0,U,e),U-=3;m=a.Cartesian3.fromArray(E,3*u,m),f=a.Cartesian3.subtract(a.Cartesian3.fromArray(E,3*c,f),m,f),g=a.Cartesian3.subtract(a.Cartesian3.fromArray(E,3*(c-t),g),m,g),W=a.Cartesian3.normalize(a.Cartesian3.add(f,g,W),W),I(P,Y,W,B,void 0,e),B+=3}else{for(I(P,Y,W,B,void 0,e),B+=3,u=R,c=k,t=0;t<s.length/3;t++)m=a.Cartesian3.fromArray(s,3*t,m),j[J++]=u,j[J++]=c+t,j[J++]=c+t+1,l.CorridorGeometryLibrary.addAttribute(E,m,B),f=a.Cartesian3.fromArray(E,3*u,f),g=a.Cartesian3.fromArray(E,3*(c+t),g),W=a.Cartesian3.normalize(a.Cartesian3.subtract(f,g,W),W),I(P,Y,W,B,void 0,e),B+=3;m=a.Cartesian3.fromArray(E,3*u,m),f=a.Cartesian3.subtract(a.Cartesian3.fromArray(E,3*(c+t),f),m,f),g=a.Cartesian3.subtract(a.Cartesian3.fromArray(E,3*c,g),m,g),W=a.Cartesian3.normalize(a.Cartesian3.negate(a.Cartesian3.add(g,f,W),W),W),I(P,Y,W,void 0,U,e),U-=3}for($=i[X++],tt=i[X++],$.splice(0,3),tt.splice(tt.length-3,3),E.set($,B),E.set(tt,U-tt.length+1),C=tt.length-3,Z+=3,W=a.Cartesian3.fromArray(y,Z,W),t=0;t<tt.length;t+=3)K=r.geodeticSurfaceNormal(a.Cartesian3.fromArray($,t,M),M),Q=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(tt,C-t,D),D),Y=a.Cartesian3.normalize(a.Cartesian3.add(K,Q,Y),Y),I(P,Y,W,B,U,e),k=B/3,S=k-1,R=(U-2)/3,O=R+1,j[J++]=O,j[J++]=S,j[J++]=R,j[J++]=R,j[J++]=S,j[J++]=k,B+=3,U-=3;B-=3,U+=3}if(Y=a.Cartesian3.fromArray(p,p.length-3,Y),I(P,Y,W,B,U,e),v){B+=3,U-=3,z=F,H=L;const t=s[1];for(b=0;b<q;b++)z=a.Cartesian3.fromArray(t,3*(T-b-1),z),H=a.Cartesian3.fromArray(t,3*b,H),l.CorridorGeometryLibrary.addAttribute(E,z,void 0,U),l.CorridorGeometryLibrary.addAttribute(E,H,B),I(P,Y,W,B,U,e),k=B/3,S=k-1,R=(U-2)/3,O=R+1,j[J++]=O,j[J++]=S,j[J++]=R,j[J++]=R,j[J++]=S,j[J++]=k,B+=3,U-=3}if(g.position=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:E}),e.st){const t=new Float32Array(G/3*2);let e,r,a=0;if(v){A/=3,_/=3;const i=Math.PI/(T+1);let o;r=1/(A-T+1),e=1/(_-T+1);const n=T/2;for(b=n+1;b<T+1;b++)o=f.CesiumMath.PI_OVER_TWO+i*b,t[a++]=e*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(b=1;b<_-T+1;b++)t[a++]=b*e,t[a++]=0;for(b=T;b>n;b--)o=f.CesiumMath.PI_OVER_TWO-b*i,t[a++]=1-e*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(b=n;b>0;b--)o=f.CesiumMath.PI_OVER_TWO-i*b,t[a++]=1-r*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(b=A-T;b>0;b--)t[a++]=b*r,t[a++]=1;for(b=1;b<n+1;b++)o=f.CesiumMath.PI_OVER_TWO+i*b,t[a++]=r*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o))}else{for(A/=3,_/=3,r=1/(A-1),e=1/(_-1),b=0;b<_;b++)t[a++]=b*e,t[a++]=0;for(b=A;b>0;b--)t[a++]=(b-1)*r,t[a++]=1}g.st=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(g.normal=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P.normals})),e.tangent&&(g.tangent=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P.tangents})),e.bitangent&&(g.bitangent=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P.bitangents})),{attributes:g,indices:j}}function R(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function k(e,r){const i=new g.VertexFormat({position:r.position,normal:r.normal||r.bitangent||e.shadowVolume,tangent:r.tangent,bitangent:r.normal||r.bitangent,st:r.st}),o=e.ellipsoid,s=S(l.CorridorGeometryLibrary.computePositions(e),i,o),c=e.height,f=e.extrudedHeight;let p=s.attributes;const h=s.indices;let b=p.position.values,C=b.length;const A=new Float64Array(6*C);let _=new Float64Array(C);_.set(b);let w,v=new Float64Array(4*C);b=y.PolygonPipeline.scaleToGeodeticHeight(b,c,o),v=R(b,0,v),_=y.PolygonPipeline.scaleToGeodeticHeight(_,f,o),v=R(_,2*C,v),A.set(b),A.set(_,C),A.set(v,2*C),p.position.values=A,p=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const r=t.position.values;let i,o;(e.normal||e.bitangent)&&(i=t.normal.values,o=t.bitangent.values);const n=t.position.values.length/18,s=3*n,d=2*n,u=2*s;let c;if(e.normal||e.bitangent||e.tangent){const n=e.normal?new Float32Array(6*s):void 0,d=e.tangent?new Float32Array(6*s):void 0,m=e.bitangent?new Float32Array(6*s):void 0;let f=V,y=x,p=F,g=L,h=P,b=N,C=u;for(c=0;c<s;c+=3){const t=C+u;f=a.Cartesian3.fromArray(r,c,f),y=a.Cartesian3.fromArray(r,c+s,y),p=a.Cartesian3.fromArray(r,(c+3)%s,p),y=a.Cartesian3.subtract(y,f,y),p=a.Cartesian3.subtract(p,f,p),g=a.Cartesian3.normalize(a.Cartesian3.cross(y,p,g),g),e.normal&&(l.CorridorGeometryLibrary.addAttribute(n,g,t),l.CorridorGeometryLibrary.addAttribute(n,g,t+3),l.CorridorGeometryLibrary.addAttribute(n,g,C),l.CorridorGeometryLibrary.addAttribute(n,g,C+3)),(e.tangent||e.bitangent)&&(b=a.Cartesian3.fromArray(i,c,b),e.bitangent&&(l.CorridorGeometryLibrary.addAttribute(m,b,t),l.CorridorGeometryLibrary.addAttribute(m,b,t+3),l.CorridorGeometryLibrary.addAttribute(m,b,C),l.CorridorGeometryLibrary.addAttribute(m,b,C+3)),e.tangent&&(h=a.Cartesian3.normalize(a.Cartesian3.cross(b,g,h),h),l.CorridorGeometryLibrary.addAttribute(d,h,t),l.CorridorGeometryLibrary.addAttribute(d,h,t+3),l.CorridorGeometryLibrary.addAttribute(d,h,C),l.CorridorGeometryLibrary.addAttribute(d,h,C+3))),C+=6}if(e.normal){for(n.set(i),c=0;c<s;c+=3)n[c+s]=-i[c],n[c+s+1]=-i[c+1],n[c+s+2]=-i[c+2];t.normal.values=n}else t.normal=void 0;if(e.bitangent?(m.set(o),m.set(o,s),t.bitangent.values=m):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,s),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],c=2;c<d;c+=2){const t=e[c],i=e[c+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(p,r);const T=C/3;if(e.shadowVolume){const t=p.normal.values;C=t.length;let e=new Float32Array(6*C);for(w=0;w<C;w++)t[w]=-t[w];e.set(t,C),e=R(t,4*C,e),p.extrudeDirection=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e}),r.normal||(p.normal=void 0)}if(d.defined(e.offsetAttribute)){let r=new Uint8Array(6*T);if(e.offsetAttribute===t.GeometryOffsetAttribute.TOP)r=t.arrayFill(r,1,0,T),r=t.arrayFill(r,1,2*T,4*T);else{const a=e.offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;r=t.arrayFill(r,a)}p.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}const G=h.length,E=T+T,M=m.IndexDatatype.createTypedArray(A.length/3,2*G+3*E);M.set(h);let D,O,I,k,H=G;for(w=0;w<G;w+=3){const t=h[w],e=h[w+1],r=h[w+2];M[H++]=r+T,M[H++]=e+T,M[H++]=t+T}for(w=0;w<E;w+=2)D=w+E,O=D+E,I=D+1,k=O+1,M[H++]=D,M[H++]=O,M[H++]=I,M[H++]=I,M[H++]=O,M[H++]=k;return{attributes:p,indices:M}}const H=new a.Cartesian3,z=new a.Cartesian3,B=new i.Cartographic;function U(t,e,r,i,o,n){const s=a.Cartesian3.subtract(e,t,H);a.Cartesian3.normalize(s,s);const l=r.geodeticSurfaceNormal(t,z),d=a.Cartesian3.cross(s,l,H);a.Cartesian3.multiplyByScalar(d,i,d);let u=o.latitude,c=o.longitude,m=n.latitude,f=n.longitude;a.Cartesian3.add(t,d,z),r.cartesianToCartographic(z,B);let y=B.latitude,p=B.longitude;u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),a.Cartesian3.subtract(t,d,z),r.cartesianToCartographic(z,B),y=B.latitude,p=B.longitude,u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),o.latitude=u,o.longitude=c,n.latitude=m,n.longitude=f}const Y=new a.Cartesian3,W=new a.Cartesian3,q=new i.Cartographic,j=new i.Cartographic;function J(t,r,i,o,n){t=O(t,r);const l=e.arrayRemoveDuplicates(t,a.Cartesian3.equalsEpsilon),u=l.length;if(u<2||i<=0)return new p.Rectangle;const c=.5*i;let m,f;if(q.latitude=Number.POSITIVE_INFINITY,q.longitude=Number.POSITIVE_INFINITY,j.latitude=Number.NEGATIVE_INFINITY,j.longitude=Number.NEGATIVE_INFINITY,o===s.CornerType.ROUNDED){const t=l[0];a.Cartesian3.subtract(t,l[1],Y),a.Cartesian3.normalize(Y,Y),a.Cartesian3.multiplyByScalar(Y,c,Y),a.Cartesian3.add(t,Y,W),r.cartesianToCartographic(W,B),m=B.latitude,f=B.longitude,q.latitude=Math.min(q.latitude,m),q.longitude=Math.min(q.longitude,f),j.latitude=Math.max(j.latitude,m),j.longitude=Math.max(j.longitude,f)}for(let t=0;t<u-1;++t)U(l[t],l[t+1],r,c,q,j);const y=l[u-1];a.Cartesian3.subtract(y,l[u-2],Y),a.Cartesian3.normalize(Y,Y),a.Cartesian3.multiplyByScalar(Y,c,Y),a.Cartesian3.add(y,Y,W),U(y,W,r,c,q,j),o===s.CornerType.ROUNDED&&(r.cartesianToCartographic(W,B),m=B.latitude,f=B.longitude,q.latitude=Math.min(q.latitude,m),q.longitude=Math.min(q.longitude,f),j.latitude=Math.max(j.latitude,m),j.longitude=Math.max(j.longitude,f));const g=d.defined(n)?n:new p.Rectangle;return g.north=j.latitude,g.south=q.latitude,g.east=j.longitude,g.west=q.longitude,g}function K(t){const e=(t=d.defaultValue(t,d.defaultValue.EMPTY_OBJECT)).positions,r=t.width,o=d.defaultValue(t.height,0),n=d.defaultValue(t.extrudedHeight,o);this._positions=e,this._ellipsoid=i.Ellipsoid.clone(d.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84)),this._vertexFormat=g.VertexFormat.clone(d.defaultValue(t.vertexFormat,g.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(o,n),this._extrudedHeight=Math.min(o,n),this._cornerType=d.defaultValue(t.cornerType,s.CornerType.ROUNDED),this._granularity=d.defaultValue(t.granularity,f.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=d.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*a.Cartesian3.packedLength+i.Ellipsoid.packedLength+g.VertexFormat.packedLength+7}K.pack=function(t,e,r){r=d.defaultValue(r,0);const o=t._positions,n=o.length;e[r++]=n;for(let t=0;t<n;++t,r+=a.Cartesian3.packedLength)a.Cartesian3.pack(o[t],e,r);return i.Ellipsoid.pack(t._ellipsoid,e,r),r+=i.Ellipsoid.packedLength,g.VertexFormat.pack(t._vertexFormat,e,r),r+=g.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=d.defaultValue(t._offsetAttribute,-1),e};const Q=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),X=new g.VertexFormat,Z={positions:void 0,ellipsoid:Q,vertexFormat:X,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return K.unpack=function(t,e,r){e=d.defaultValue(e,0);const o=t[e++],n=new Array(o);for(let r=0;r<o;++r,e+=a.Cartesian3.packedLength)n[r]=a.Cartesian3.unpack(t,e);const s=i.Ellipsoid.unpack(t,e,Q);e+=i.Ellipsoid.packedLength;const l=g.VertexFormat.unpack(t,e,X);e+=g.VertexFormat.packedLength;const u=t[e++],c=t[e++],m=t[e++],f=t[e++],y=t[e++],p=1===t[e++],h=t[e];return d.defined(r)?(r._positions=n,r._ellipsoid=i.Ellipsoid.clone(s,r._ellipsoid),r._vertexFormat=g.VertexFormat.clone(l,r._vertexFormat),r._width=u,r._height=c,r._extrudedHeight=m,r._cornerType=f,r._granularity=y,r._shadowVolume=p,r._offsetAttribute=-1===h?void 0:h,r):(Z.positions=n,Z.width=u,Z.height=c,Z.extrudedHeight=m,Z.cornerType=f,Z.granularity=y,Z.shadowVolume=p,Z.offsetAttribute=-1===h?void 0:h,new K(Z))},K.computeRectangle=function(t,e){const r=(t=d.defaultValue(t,d.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return J(r,d.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84),a,d.defaultValue(t.cornerType,s.CornerType.ROUNDED),e)},K.createGeometry=function(i){let o=i._positions;const s=i._width,c=i._ellipsoid;o=O(o,c);const m=e.arrayRemoveDuplicates(o,a.Cartesian3.equalsEpsilon);if(m.length<2||s<=0)return;const p=i._height,g=i._extrudedHeight,h=!f.CesiumMath.equalsEpsilon(p,g,0,f.CesiumMath.EPSILON2),b=i._vertexFormat,C={ellipsoid:c,positions:m,width:s,cornerType:i._cornerType,granularity:i._granularity,saveAttributes:!0};let A;if(h)C.height=p,C.extrudedHeight=g,C.shadowVolume=i._shadowVolume,C.offsetAttribute=i._offsetAttribute,A=k(C,b);else{if(A=S(l.CorridorGeometryLibrary.computePositions(C),b,c),A.attributes.position.values=y.PolygonPipeline.scaleToGeodeticHeight(A.attributes.position.values,p,c),d.defined(i._offsetAttribute)){const e=i._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1,r=A.attributes.position.values.length,a=new Uint8Array(r/3);t.arrayFill(a,e),A.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}}const _=A.attributes,w=r.BoundingSphere.fromVertices(_.position.values,void 0,3);return b.position||(A.attributes.position.values=void 0),new u.Geometry({attributes:_,indices:A.indices,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:w,offsetAttribute:i._offsetAttribute})},K.createShadowVolume=function(t,e,r){const a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new K({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:g.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(K.prototype,{rectangle:{get:function(){return d.defined(this._rectangle)||(this._rectangle=J(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return d.defined(e)&&(t=K.unpack(t,e)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),K.createGeometry(t)}}));
