define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-51e2663f","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./defaultValue-81eec7ed","./RuntimeError-8952249c","./Ellipsoid-119327cb","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304"],(function(t,i,e,n,a,o,r,s,u,m,c,f){"use strict";const l=new n.Cartesian3(1,1,1),d=Math.cos,C=Math.sin;function _(t){t=o.defaultValue(t,o.defaultValue.EMPTY_OBJECT);const i=o.defaultValue(t.radii,l),e=o.defaultValue(t.innerRadii,i),a=o.defaultValue(t.minimumClock,0),r=o.defaultValue(t.maximumClock,f.CesiumMath.TWO_PI),s=o.defaultValue(t.minimumCone,0),u=o.defaultValue(t.maximumCone,f.CesiumMath.PI),m=Math.round(o.defaultValue(t.stackPartitions,10)),c=Math.round(o.defaultValue(t.slicePartitions,8)),d=Math.round(o.defaultValue(t.subdivisions,128));this._radii=n.Cartesian3.clone(i),this._innerRadii=n.Cartesian3.clone(e),this._minimumClock=a,this._maximumClock=r,this._minimumCone=s,this._maximumCone=u,this._stackPartitions=m,this._slicePartitions=c,this._subdivisions=d,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}_.packedLength=2*n.Cartesian3.packedLength+8,_.pack=function(t,i,e){return e=o.defaultValue(e,0),n.Cartesian3.pack(t._radii,i,e),e+=n.Cartesian3.packedLength,n.Cartesian3.pack(t._innerRadii,i,e),e+=n.Cartesian3.packedLength,i[e++]=t._minimumClock,i[e++]=t._maximumClock,i[e++]=t._minimumCone,i[e++]=t._maximumCone,i[e++]=t._stackPartitions,i[e++]=t._slicePartitions,i[e++]=t._subdivisions,i[e]=o.defaultValue(t._offsetAttribute,-1),i};const p=new n.Cartesian3,h=new n.Cartesian3,y={radii:p,innerRadii:h,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};_.unpack=function(t,i,e){i=o.defaultValue(i,0);const a=n.Cartesian3.unpack(t,i,p);i+=n.Cartesian3.packedLength;const r=n.Cartesian3.unpack(t,i,h);i+=n.Cartesian3.packedLength;const s=t[i++],u=t[i++],m=t[i++],c=t[i++],f=t[i++],l=t[i++],d=t[i++],C=t[i];return o.defined(e)?(e._radii=n.Cartesian3.clone(a,e._radii),e._innerRadii=n.Cartesian3.clone(r,e._innerRadii),e._minimumClock=s,e._maximumClock=u,e._minimumCone=m,e._maximumCone=c,e._stackPartitions=f,e._slicePartitions=l,e._subdivisions=d,e._offsetAttribute=-1===C?void 0:C,e):(y.minimumClock=s,y.maximumClock=u,y.minimumCone=m,y.maximumCone=c,y.stackPartitions=f,y.slicePartitions=l,y.subdivisions=d,y.offsetAttribute=-1===C?void 0:C,new _(y))},_.createGeometry=function(t){const n=t._radii;if(n.x<=0||n.y<=0||n.z<=0)return;const r=t._innerRadii;if(r.x<=0||r.y<=0||r.z<=0)return;const l=t._minimumClock,_=t._maximumClock,p=t._minimumCone,h=t._maximumCone,y=t._subdivisions,b=s.Ellipsoid.fromCartesian3(n);let k=t._slicePartitions+1,x=t._stackPartitions+1;k=Math.round(k*Math.abs(_-l)/f.CesiumMath.TWO_PI),x=Math.round(x*Math.abs(h-p)/f.CesiumMath.PI),k<2&&(k=2),x<2&&(x=2);let A=0,P=1;const v=r.x!==n.x||r.y!==n.y||r.z!==n.z;let M=!1,w=!1;v&&(P=2,p>0&&(M=!0,A+=k),h<Math.PI&&(w=!0,A+=k));const V=y*P*(x+k),g=new Float64Array(3*V),E=2*(V+A-(k+x)*P),G=c.IndexDatatype.createTypedArray(V,E);let O,D,I,T,z=0;const L=new Array(x),R=new Array(x);for(O=0;O<x;O++)T=p+O*(h-p)/(x-1),L[O]=C(T),R[O]=d(T);const N=new Array(y),B=new Array(y);for(O=0;O<y;O++)I=l+O*(_-l)/(y-1),N[O]=C(I),B[O]=d(I);for(O=0;O<x;O++)for(D=0;D<y;D++)g[z++]=n.x*L[O]*B[D],g[z++]=n.y*L[O]*N[D],g[z++]=n.z*R[O];if(v)for(O=0;O<x;O++)for(D=0;D<y;D++)g[z++]=r.x*L[O]*B[D],g[z++]=r.y*L[O]*N[D],g[z++]=r.z*R[O];for(L.length=y,R.length=y,O=0;O<y;O++)T=p+O*(h-p)/(y-1),L[O]=C(T),R[O]=d(T);for(N.length=k,B.length=k,O=0;O<k;O++)I=l+O*(_-l)/(k-1),N[O]=C(I),B[O]=d(I);for(O=0;O<y;O++)for(D=0;D<k;D++)g[z++]=n.x*L[O]*B[D],g[z++]=n.y*L[O]*N[D],g[z++]=n.z*R[O];if(v)for(O=0;O<y;O++)for(D=0;D<k;D++)g[z++]=r.x*L[O]*B[D],g[z++]=r.y*L[O]*N[D],g[z++]=r.z*R[O];for(z=0,O=0;O<x*P;O++){const t=O*y;for(D=0;D<y-1;D++)G[z++]=t+D,G[z++]=t+D+1}let S=x*y*P;for(O=0;O<k;O++)for(D=0;D<y-1;D++)G[z++]=S+O+D*k,G[z++]=S+O+(D+1)*k;if(v)for(S=x*y*P+k*y,O=0;O<k;O++)for(D=0;D<y-1;D++)G[z++]=S+O+D*k,G[z++]=S+O+(D+1)*k;if(v){let t=x*y*P,i=t+y*k;if(M)for(O=0;O<k;O++)G[z++]=t+O,G[z++]=i+O;if(w)for(t+=y*k-k,i+=y*k-k,O=0;O<k;O++)G[z++]=t+O,G[z++]=i+O}const U=new m.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})});if(o.defined(t._offsetAttribute)){const e=g.length,n=new Uint8Array(e/3),o=t._offsetAttribute===i.GeometryOffsetAttribute.NONE?0:1;i.arrayFill(n,o),U.applyOffset=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new u.Geometry({attributes:U,indices:G,primitiveType:u.PrimitiveType.LINES,boundingSphere:e.BoundingSphere.fromEllipsoid(b),offsetAttribute:t._offsetAttribute})},t.EllipsoidOutlineGeometry=_}));
