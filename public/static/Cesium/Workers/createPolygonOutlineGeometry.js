define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./ArcType-fc72c06c","./GeometryOffsetAttribute-8c5e10db","./Transforms-51e2663f","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./EllipsoidTangentPlane-6354c9aa","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./GeometryInstance-57a5edd8","./GeometryPipeline-1ba2ded0","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonGeometryLibrary-0ef79c97","./PolygonPipeline-ef9e08dd","./Matrix4-3b2c0630","./Matrix2-115e2170","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./AttributeCompression-cf8328fe","./EncodedCartesian3-e203d8be","./arrayRemoveDuplicates-4bbe2c1f","./EllipsoidRhumbLine-6fa5d271"],(function(e,t,i,o,r,n,a,l,s,y,u,p,c,d,f,g,m,h,b,P,E,A,_,G,L,H,T,v){"use strict";const x=[],O=[];function C(e,t,o,r,n){const p=l.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,x);let d,m;g.PolygonPipeline.computeWindingOrder2D(p)===g.WindingOrder.CLOCKWISE&&(p.reverse(),t=t.slice().reverse());let h=t.length,b=0;if(r)for(d=new Float64Array(2*h*3),m=0;m<h;m++){const e=t[m],i=t[(m+1)%h];d[b++]=e.x,d[b++]=e.y,d[b++]=e.z,d[b++]=i.x,d[b++]=i.y,d[b++]=i.z}else{let r=0;if(n===i.ArcType.GEODESIC)for(m=0;m<h;m++)r+=f.PolygonGeometryLibrary.subdivideLineCount(t[m],t[(m+1)%h],o);else if(n===i.ArcType.RHUMB)for(m=0;m<h;m++)r+=f.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[m],t[(m+1)%h],o);for(d=new Float64Array(3*r),m=0;m<h;m++){let r;n===i.ArcType.GEODESIC?r=f.PolygonGeometryLibrary.subdivideLine(t[m],t[(m+1)%h],o,O):n===i.ArcType.RHUMB&&(r=f.PolygonGeometryLibrary.subdivideRhumbLine(e,t[m],t[(m+1)%h],o,O));const a=r.length;for(let e=0;e<a;++e)d[b++]=r[e]}}h=d.length/3;const P=2*h,E=c.IndexDatatype.createTypedArray(h,P);for(b=0,m=0;m<h-1;m++)E[b++]=m,E[b++]=m+1;return E[b++]=h-1,E[b++]=0,new u.GeometryInstance({geometry:new s.Geometry({attributes:new y.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})}),indices:E,primitiveType:s.PrimitiveType.LINES})})}function D(e,t,o,r,n){const p=l.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,x);let d,m;g.PolygonPipeline.computeWindingOrder2D(p)===g.WindingOrder.CLOCKWISE&&(p.reverse(),t=t.slice().reverse());let h=t.length;const b=new Array(h);let P=0;if(r)for(d=new Float64Array(2*h*3*2),m=0;m<h;++m){b[m]=P/3;const e=t[m],i=t[(m+1)%h];d[P++]=e.x,d[P++]=e.y,d[P++]=e.z,d[P++]=i.x,d[P++]=i.y,d[P++]=i.z}else{let r=0;if(n===i.ArcType.GEODESIC)for(m=0;m<h;m++)r+=f.PolygonGeometryLibrary.subdivideLineCount(t[m],t[(m+1)%h],o);else if(n===i.ArcType.RHUMB)for(m=0;m<h;m++)r+=f.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[m],t[(m+1)%h],o);for(d=new Float64Array(3*r*2),m=0;m<h;++m){let r;b[m]=P/3,n===i.ArcType.GEODESIC?r=f.PolygonGeometryLibrary.subdivideLine(t[m],t[(m+1)%h],o,O):n===i.ArcType.RHUMB&&(r=f.PolygonGeometryLibrary.subdivideRhumbLine(e,t[m],t[(m+1)%h],o,O));const a=r.length;for(let e=0;e<a;++e)d[P++]=r[e]}}h=d.length/6;const E=b.length,A=2*(2*h+E),_=c.IndexDatatype.createTypedArray(h+E,A);for(P=0,m=0;m<h;++m)_[P++]=m,_[P++]=(m+1)%h,_[P++]=m+h,_[P++]=(m+1)%h+h;for(m=0;m<E;m++){const e=b[m];_[P++]=e,_[P++]=e+h}return new u.GeometryInstance({geometry:new s.Geometry({attributes:new y.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})}),indices:_,primitiveType:s.PrimitiveType.LINES})})}function I(o){const r=o.polygonHierarchy,n=e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84),a=e.defaultValue(o.granularity,d.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(o.perPositionHeight,!1),s=l&&e.defined(o.extrudedHeight),y=e.defaultValue(o.arcType,i.ArcType.GEODESIC);let u=e.defaultValue(o.height,0),p=e.defaultValue(o.extrudedHeight,u);if(!s){const e=Math.max(u,p);p=Math.min(u,p),u=e}this._ellipsoid=t.Ellipsoid.clone(n),this._granularity=a,this._height=u,this._extrudedHeight=p,this._arcType=y,this._polygonHierarchy=r,this._perPositionHeight=l,this._perPositionHeightExtrude=s,this._offsetAttribute=o.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=f.PolygonGeometryLibrary.computeHierarchyPackedLength(r)+t.Ellipsoid.packedLength+8}I.pack=function(i,o,r){return r=e.defaultValue(r,0),r=f.PolygonGeometryLibrary.packPolygonHierarchy(i._polygonHierarchy,o,r),t.Ellipsoid.pack(i._ellipsoid,o,r),r+=t.Ellipsoid.packedLength,o[r++]=i._height,o[r++]=i._extrudedHeight,o[r++]=i._granularity,o[r++]=i._perPositionHeightExtrude?1:0,o[r++]=i._perPositionHeight?1:0,o[r++]=i._arcType,o[r++]=e.defaultValue(i._offsetAttribute,-1),o[r]=i.packedLength,o};const w=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),S={polygonHierarchy:{}};return I.unpack=function(i,o,r){o=e.defaultValue(o,0);const n=f.PolygonGeometryLibrary.unpackPolygonHierarchy(i,o);o=n.startingIndex,delete n.startingIndex;const a=t.Ellipsoid.unpack(i,o,w);o+=t.Ellipsoid.packedLength;const l=i[o++],s=i[o++],y=i[o++],u=1===i[o++],p=1===i[o++],c=i[o++],d=i[o++],g=i[o];return e.defined(r)||(r=new I(S)),r._polygonHierarchy=n,r._ellipsoid=t.Ellipsoid.clone(a,r._ellipsoid),r._height=l,r._extrudedHeight=s,r._granularity=y,r._perPositionHeight=p,r._perPositionHeightExtrude=u,r._arcType=c,r._offsetAttribute=-1===d?void 0:d,r.packedLength=g,r},I.fromPositions=function(t){return new I({polygonHierarchy:{positions:(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,arcType:t.arcType,offsetAttribute:t.offsetAttribute})},I.createGeometry=function(t){const i=t._ellipsoid,n=t._granularity,l=t._polygonHierarchy,y=t._perPositionHeight,u=t._arcType,c=f.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(l,!y,i);if(0===c.length)return;let m;const h=[],b=d.CesiumMath.chordLength(n,i.maximumRadius),P=t._height,E=t._extrudedHeight;let A,_;if(t._perPositionHeightExtrude||!d.CesiumMath.equalsEpsilon(P,E,0,d.CesiumMath.EPSILON2))for(_=0;_<c.length;_++){if(m=D(i,c[_],b,y,u),m.geometry=f.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(m.geometry,P,E,i,y),e.defined(t._offsetAttribute)){const e=m.geometry.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===o.GeometryOffsetAttribute.TOP?i=o.arrayFill(i,1,0,e/2):(A=t._offsetAttribute===o.GeometryOffsetAttribute.NONE?0:1,i=o.arrayFill(i,A)),m.geometry.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(m)}else for(_=0;_<c.length;_++){if(m=C(i,c[_],b,y,u),m.geometry.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(m.geometry.attributes.position.values,P,i,!y),e.defined(t._offsetAttribute)){const e=m.geometry.attributes.position.values.length,i=new Uint8Array(e/3);A=t._offsetAttribute===o.GeometryOffsetAttribute.NONE?0:1,o.arrayFill(i,A),m.geometry.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(m)}const G=p.GeometryPipeline.combineInstances(h)[0],L=r.BoundingSphere.fromVertices(G.attributes.position.values);return new s.Geometry({attributes:G.attributes,indices:G.indices,primitiveType:G.primitiveType,boundingSphere:L,offsetAttribute:t._offsetAttribute})},function(i,o){return e.defined(o)&&(i=I.unpack(i,o)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),I.createGeometry(i)}}));
