define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./Matrix2-115e2170","./GeometryOffsetAttribute-8c5e10db","./Transforms-51e2663f","./Matrix4-3b2c0630","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./GeometryInstance-57a5edd8","./GeometryPipeline-1ba2ded0","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonPipeline-ef9e08dd","./RectangleGeometryLibrary-fc9e05a4","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AttributeCompression-cf8328fe","./EncodedCartesian3-e203d8be","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./EllipsoidRhumbLine-6fa5d271"],(function(t,e,n,a,o,r,i,s,l,u,c,m,d,p,g,y,f,h,b,_,A,x,w,C,v){"use strict";const R=new r.Cartesian3,E=new r.Cartesian3,F=new r.Cartesian3,G=new r.Cartesian3,P=new n.Rectangle,V=new n.Cartesian2,L=new o.BoundingSphere,D=new o.BoundingSphere;function M(t,e){const n=new l.Geometry({attributes:new u.GeometryAttributes,primitiveType:l.PrimitiveType.TRIANGLES});return n.attributes.position=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}const T=new r.Cartesian3,O=new r.Cartesian3;function N(t,e){const n=t._vertexFormat,a=t._ellipsoid,o=e.height,i=e.width,u=e.northCap,c=e.southCap;let m=0,p=o,g=o,f=0;u&&(m=1,g-=1,f+=1),c&&(p-=1,g-=1,f+=1),f+=i*g;const h=n.position?new Float64Array(3*f):void 0,b=n.st?new Float32Array(2*f):void 0;let _=0,A=0;const x=R,w=V;let C=Number.MAX_VALUE,v=Number.MAX_VALUE,P=-Number.MAX_VALUE,L=-Number.MAX_VALUE;for(let t=m;t<p;++t)for(let o=0;o<i;++o)y.RectangleGeometryLibrary.computePosition(e,a,n.st,t,o,x,w),h[_++]=x.x,h[_++]=x.y,h[_++]=x.z,n.st&&(b[A++]=w.x,b[A++]=w.y,C=Math.min(C,w.x),v=Math.min(v,w.y),P=Math.max(P,w.x),L=Math.max(L,w.y));if(u&&(y.RectangleGeometryLibrary.computePosition(e,a,n.st,0,0,x,w),h[_++]=x.x,h[_++]=x.y,h[_++]=x.z,n.st&&(b[A++]=w.x,b[A++]=w.y,C=w.x,v=w.y,P=w.x,L=w.y)),c&&(y.RectangleGeometryLibrary.computePosition(e,a,n.st,o-1,0,x,w),h[_++]=x.x,h[_++]=x.y,h[_]=x.z,n.st&&(b[A++]=w.x,b[A]=w.y,C=Math.min(C,w.x),v=Math.min(v,w.y),P=Math.max(P,w.x),L=Math.max(L,w.y))),n.st&&(C<0||v<0||P>1||L>1))for(let t=0;t<b.length;t+=2)b[t]=(b[t]-C)/(P-C),b[t+1]=(b[t+1]-v)/(L-v);const D=function(t,e,n,a){const o=t.length,i=e.normal?new Float32Array(o):void 0,s=e.tangent?new Float32Array(o):void 0,l=e.bitangent?new Float32Array(o):void 0;let u=0;const c=G,m=F;let d=E;if(e.normal||e.tangent||e.bitangent)for(let p=0;p<o;p+=3){const o=r.Cartesian3.fromArray(t,p,R),g=u+1,y=u+2;d=n.geodeticSurfaceNormal(o,d),(e.tangent||e.bitangent)&&(r.Cartesian3.cross(r.Cartesian3.UNIT_Z,d,m),r.Matrix3.multiplyByVector(a,m,m),r.Cartesian3.normalize(m,m),e.bitangent&&r.Cartesian3.normalize(r.Cartesian3.cross(d,m,c),c)),e.normal&&(i[u]=d.x,i[g]=d.y,i[y]=d.z),e.tangent&&(s[u]=m.x,s[g]=m.y,s[y]=m.z),e.bitangent&&(l[u]=c.x,l[g]=c.y,l[y]=c.z),u+=3}return M(e,{positions:t,normals:i,tangents:s,bitangents:l})}(h,n,a,e.tangentRotationMatrix);let T=6*(i-1)*(g-1);u&&(T+=3*(i-1)),c&&(T+=3*(i-1));const O=d.IndexDatatype.createTypedArray(f,T);let N,S=0,I=0;for(N=0;N<g-1;++N){for(let t=0;t<i-1;++t){const t=S,e=t+i,n=e+1,a=t+1;O[I++]=t,O[I++]=e,O[I++]=a,O[I++]=a,O[I++]=e,O[I++]=n,++S}++S}if(u||c){let t=f-1;const e=f-1;let n,a;if(u&&c&&(t=f-2),S=0,u)for(N=0;N<i-1;N++)n=S,a=n+1,O[I++]=t,O[I++]=n,O[I++]=a,++S;if(c)for(S=(g-1)*i,N=0;N<i-1;N++)n=S,a=n+1,O[I++]=n,O[I++]=e,O[I++]=a,++S}return D.indices=O,n.st&&(D.attributes.st=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:b})),D}function S(t,e,n,a,o){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n+2],t[e++]=o[n],t[e++]=o[n+1],t[e]=o[n+2],t}function I(t,e,n,a){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n],t[e]=a[n+1],t}const k=new f.VertexFormat;function H(e,n){const o=e._shadowVolume,i=e._offsetAttribute,u=e._vertexFormat,y=e._extrudedHeight,h=e._surfaceHeight,b=e._ellipsoid,_=n.height,A=n.width;let x;if(o){const t=f.VertexFormat.clone(u,k);t.normal=!0,e._vertexFormat=t}const w=N(e,n);o&&(e._vertexFormat=u);let C=g.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,h,b,!1);C=new Float64Array(C);let v=C.length;const P=2*v,V=new Float64Array(P);V.set(C);const L=g.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,y,b);V.set(L,v),w.attributes.position.values=V;const D=u.normal?new Float32Array(P):void 0,H=u.tangent?new Float32Array(P):void 0,z=u.bitangent?new Float32Array(P):void 0,B=u.st?new Float32Array(P/3*2):void 0;let U,Y,q;if(u.normal){for(Y=w.attributes.normal.values,D.set(Y),x=0;x<v;x++)Y[x]=-Y[x];D.set(Y,v),w.attributes.normal.values=D}if(o){Y=w.attributes.normal.values,u.normal||(w.attributes.normal=void 0);const t=new Float32Array(P);for(x=0;x<v;x++)Y[x]=-Y[x];t.set(Y,v),w.attributes.extrudeDirection=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})}const X=t.defined(i);if(X){const t=v/3*2;let e=new Uint8Array(t);i===a.GeometryOffsetAttribute.TOP?e=a.arrayFill(e,1,0,t/2):(q=i===a.GeometryOffsetAttribute.NONE?0:1,e=a.arrayFill(e,q)),w.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(u.tangent){const t=w.attributes.tangent.values;for(H.set(t),x=0;x<v;x++)t[x]=-t[x];H.set(t,v),w.attributes.tangent.values=H}if(u.bitangent){const t=w.attributes.bitangent.values;z.set(t),z.set(t,v),w.attributes.bitangent.values=z}u.st&&(U=w.attributes.st.values,B.set(U),B.set(U,v/3*2),w.attributes.st.values=B);const Q=w.indices,W=Q.length,j=v/3,J=d.IndexDatatype.createTypedArray(P/3,2*W);for(J.set(Q),x=0;x<W;x+=3)J[x+W]=Q[x+2]+j,J[x+1+W]=Q[x+1]+j,J[x+2+W]=Q[x]+j;w.indices=J;const Z=n.northCap,K=n.southCap;let $=_,tt=2,et=0,nt=4,at=4;Z&&(tt-=1,$-=1,et+=1,nt-=2,at-=1),K&&(tt-=1,$-=1,et+=1,nt-=2,at-=1),et+=tt*A+2*$-nt;const ot=2*(et+at);let rt=new Float64Array(3*ot);const it=o?new Float32Array(3*ot):void 0;let st=X?new Uint8Array(ot):void 0,lt=u.st?new Float32Array(2*ot):void 0;const ut=i===a.GeometryOffsetAttribute.TOP;X&&!ut&&(q=i===a.GeometryOffsetAttribute.ALL?1:0,st=a.arrayFill(st,q));let ct=0,mt=0,dt=0,pt=0;const gt=A*$;let yt;for(x=0;x<gt;x+=A)yt=3*x,rt=S(rt,ct,yt,C,L),ct+=6,u.st&&(lt=I(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);if(K){const t=Z?gt+1:gt;for(yt=3*t,x=0;x<2;x++)rt=S(rt,ct,yt,C,L),ct+=6,u.st&&(lt=I(lt,mt,2*t,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1)}else for(x=gt-A;x<gt;x++)yt=3*x,rt=S(rt,ct,yt,C,L),ct+=6,u.st&&(lt=I(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);for(x=gt-1;x>0;x-=A)yt=3*x,rt=S(rt,ct,yt,C,L),ct+=6,u.st&&(lt=I(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);if(Z){const t=gt;for(yt=3*t,x=0;x<2;x++)rt=S(rt,ct,yt,C,L),ct+=6,u.st&&(lt=I(lt,mt,2*t,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1)}else for(x=A-1;x>=0;x--)yt=3*x,rt=S(rt,ct,yt,C,L),ct+=6,u.st&&(lt=I(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);let ft=function(t,e,n){const a=t.length,o=e.normal?new Float32Array(a):void 0,i=e.tangent?new Float32Array(a):void 0,s=e.bitangent?new Float32Array(a):void 0;let l=0,u=0,c=0,m=!0,d=G,g=F,y=E;if(e.normal||e.tangent||e.bitangent)for(let f=0;f<a;f+=6){const h=r.Cartesian3.fromArray(t,f,R),b=r.Cartesian3.fromArray(t,(f+6)%a,T);if(m){const e=r.Cartesian3.fromArray(t,(f+3)%a,O);r.Cartesian3.subtract(b,h,b),r.Cartesian3.subtract(e,h,e),y=r.Cartesian3.normalize(r.Cartesian3.cross(e,b,y),y),m=!1}r.Cartesian3.equalsEpsilon(b,h,p.CesiumMath.EPSILON10)&&(m=!0),(e.tangent||e.bitangent)&&(d=n.geodeticSurfaceNormal(h,d),e.tangent&&(g=r.Cartesian3.normalize(r.Cartesian3.cross(d,y,g),g))),e.normal&&(o[l++]=y.x,o[l++]=y.y,o[l++]=y.z,o[l++]=y.x,o[l++]=y.y,o[l++]=y.z),e.tangent&&(i[u++]=g.x,i[u++]=g.y,i[u++]=g.z,i[u++]=g.x,i[u++]=g.y,i[u++]=g.z),e.bitangent&&(s[c++]=d.x,s[c++]=d.y,s[c++]=d.z,s[c++]=d.x,s[c++]=d.y,s[c++]=d.z)}return M(e,{positions:t,normals:o,tangents:i,bitangents:s})}(rt,u,b);u.st&&(ft.attributes.st=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:lt})),o&&(ft.attributes.extrudeDirection=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:it})),X&&(ft.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:st}));const ht=d.IndexDatatype.createTypedArray(ot,6*et);let bt,_t,At,xt;v=rt.length/3;let wt=0;for(x=0;x<v-1;x+=2){bt=x,xt=(bt+2)%v;const t=r.Cartesian3.fromArray(rt,3*bt,T),e=r.Cartesian3.fromArray(rt,3*xt,O);r.Cartesian3.equalsEpsilon(t,e,p.CesiumMath.EPSILON10)||(_t=(bt+1)%v,At=(_t+2)%v,ht[wt++]=bt,ht[wt++]=_t,ht[wt++]=xt,ht[wt++]=xt,ht[wt++]=_t,ht[wt++]=At)}return ft.indices=ht,ft=m.GeometryPipeline.combineInstances([new c.GeometryInstance({geometry:w}),new c.GeometryInstance({geometry:ft})]),ft[0]}const z=[new r.Cartesian3,new r.Cartesian3,new r.Cartesian3,new r.Cartesian3],B=new e.Cartographic,U=new e.Cartographic;function Y(t,e,a,o,r){if(0===a)return n.Rectangle.clone(t,r);const i=y.RectangleGeometryLibrary.computeOptions(t,e,a,0,P,B),s=i.height,l=i.width,u=z;return y.RectangleGeometryLibrary.computePosition(i,o,!1,0,0,u[0]),y.RectangleGeometryLibrary.computePosition(i,o,!1,0,l-1,u[1]),y.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,0,u[2]),y.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,l-1,u[3]),n.Rectangle.fromCartesianArray(u,o,r)}function q(a){const o=(a=t.defaultValue(a,t.defaultValue.EMPTY_OBJECT)).rectangle,r=t.defaultValue(a.height,0),i=t.defaultValue(a.extrudedHeight,r);this._rectangle=n.Rectangle.clone(o),this._granularity=t.defaultValue(a.granularity,p.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.Ellipsoid.clone(t.defaultValue(a.ellipsoid,e.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(r,i),this._rotation=t.defaultValue(a.rotation,0),this._stRotation=t.defaultValue(a.stRotation,0),this._vertexFormat=f.VertexFormat.clone(t.defaultValue(a.vertexFormat,f.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(r,i),this._shadowVolume=t.defaultValue(a.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=a.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}q.packedLength=n.Rectangle.packedLength+e.Ellipsoid.packedLength+f.VertexFormat.packedLength+7,q.pack=function(a,o,r){return r=t.defaultValue(r,0),n.Rectangle.pack(a._rectangle,o,r),r+=n.Rectangle.packedLength,e.Ellipsoid.pack(a._ellipsoid,o,r),r+=e.Ellipsoid.packedLength,f.VertexFormat.pack(a._vertexFormat,o,r),r+=f.VertexFormat.packedLength,o[r++]=a._granularity,o[r++]=a._surfaceHeight,o[r++]=a._rotation,o[r++]=a._stRotation,o[r++]=a._extrudedHeight,o[r++]=a._shadowVolume?1:0,o[r]=t.defaultValue(a._offsetAttribute,-1),o};const X=new n.Rectangle,Q=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),W={rectangle:X,ellipsoid:Q,vertexFormat:k,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};q.unpack=function(a,o,r){o=t.defaultValue(o,0);const i=n.Rectangle.unpack(a,o,X);o+=n.Rectangle.packedLength;const s=e.Ellipsoid.unpack(a,o,Q);o+=e.Ellipsoid.packedLength;const l=f.VertexFormat.unpack(a,o,k);o+=f.VertexFormat.packedLength;const u=a[o++],c=a[o++],m=a[o++],d=a[o++],p=a[o++],g=1===a[o++],y=a[o];return t.defined(r)?(r._rectangle=n.Rectangle.clone(i,r._rectangle),r._ellipsoid=e.Ellipsoid.clone(s,r._ellipsoid),r._vertexFormat=f.VertexFormat.clone(l,r._vertexFormat),r._granularity=u,r._surfaceHeight=c,r._rotation=m,r._stRotation=d,r._extrudedHeight=p,r._shadowVolume=g,r._offsetAttribute=-1===y?void 0:y,r):(W.granularity=u,W.height=c,W.rotation=m,W.stRotation=d,W.extrudedHeight=p,W.shadowVolume=g,W.offsetAttribute=-1===y?void 0:y,new q(W))},q.computeRectangle=function(n,a){const o=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle,r=t.defaultValue(n.granularity,p.CesiumMath.RADIANS_PER_DEGREE),i=t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84);return Y(o,r,t.defaultValue(n.rotation,0),i,a)};const j=new r.Matrix3,J=new o.Quaternion,Z=new e.Cartographic;q.createGeometry=function(e){if(p.CesiumMath.equalsEpsilon(e._rectangle.north,e._rectangle.south,p.CesiumMath.EPSILON10)||p.CesiumMath.equalsEpsilon(e._rectangle.east,e._rectangle.west,p.CesiumMath.EPSILON10))return;let i=e._rectangle;const u=e._ellipsoid,c=e._rotation,m=e._stRotation,d=e._vertexFormat,f=y.RectangleGeometryLibrary.computeOptions(i,e._granularity,c,m,P,B,U),h=j;if(0!==m||0!==c){const t=n.Rectangle.center(i,Z),e=u.geodeticSurfaceNormalCartographic(t,T);o.Quaternion.fromAxisAngle(e,-m,J),r.Matrix3.fromQuaternion(J,h)}else r.Matrix3.clone(r.Matrix3.IDENTITY,h);const b=e._surfaceHeight,_=e._extrudedHeight,A=!p.CesiumMath.equalsEpsilon(b,_,0,p.CesiumMath.EPSILON2);let x,w;if(f.lonScalar=1/e._rectangle.width,f.latScalar=1/e._rectangle.height,f.tangentRotationMatrix=h,i=e._rectangle,A){x=H(e,f);const t=o.BoundingSphere.fromRectangle3D(i,u,b,D),n=o.BoundingSphere.fromRectangle3D(i,u,_,L);w=o.BoundingSphere.union(t,n)}else{if(x=N(e,f),x.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(x.attributes.position.values,b,u,!1),t.defined(e._offsetAttribute)){const t=x.attributes.position.values.length,n=new Uint8Array(t/3),o=e._offsetAttribute===a.GeometryOffsetAttribute.NONE?0:1;a.arrayFill(n,o),x.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}w=o.BoundingSphere.fromRectangle3D(i,u,b)}return d.position||delete x.attributes.position,new l.Geometry({attributes:x.attributes,indices:x.indices,primitiveType:x.primitiveType,boundingSphere:w,offsetAttribute:e._offsetAttribute})},q.createShadowVolume=function(t,e,n){const a=t._granularity,o=t._ellipsoid,r=e(a,o),i=n(a,o);return new q({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:o,stRotation:t._stRotation,granularity:a,extrudedHeight:i,height:r,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const K=new n.Rectangle,$=[new n.Cartesian2,new n.Cartesian2,new n.Cartesian2],tt=new n.Matrix2,et=new e.Cartographic;return Object.defineProperties(q.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=Y(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];const e=n.Rectangle.clone(t._rectangle,K),a=t._granularity,o=t._ellipsoid,r=Y(e,a,t._rotation-t._stRotation,o,K),i=$;i[0].x=r.west,i[0].y=r.south,i[1].x=r.west,i[1].y=r.north,i[2].x=r.east,i[2].y=r.south;const s=t.rectangle,l=n.Matrix2.fromRotation(t._stRotation,tt),u=n.Rectangle.center(s,et);for(let t=0;t<3;++t){const e=i[t];e.x-=u.longitude,e.y-=u.latitude,n.Matrix2.multiplyByVector(l,e,e),e.x+=u.longitude,e.y+=u.latitude,e.x=(e.x-s.west)/s.width,e.y=(e.y-s.south)/s.height}const c=i[0],m=i[1],d=i[2],p=new Array(6);return n.Cartesian2.pack(c,p),n.Cartesian2.pack(m,p,2),n.Cartesian2.pack(d,p,4),p}(this)),this._textureCoordinateRotationPoints}}}),function(a,o){return t.defined(o)&&(a=q.unpack(a,o)),a._ellipsoid=e.Ellipsoid.clone(a._ellipsoid),a._rectangle=n.Rectangle.clone(a._rectangle),q.createGeometry(a)}}));
