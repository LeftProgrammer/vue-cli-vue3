define(["./GeometryOffsetAttribute-8c5e10db","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./CylinderGeometryLibrary-ceeaaaea","./defaultValue-81eec7ed","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Ellipsoid-119327cb","./Math-c2b1b304","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636"],(function(t,e,i,n,o,r,a,s,u,f,c,d,l,b,m,p){"use strict";const y=new i.Cartesian2;function _(t){const e=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).length,i=t.topRadius,n=t.bottomRadius,o=s.defaultValue(t.slices,128),r=Math.max(s.defaultValue(t.numberOfVerticalLines,16),0);this._length=e,this._topRadius=i,this._bottomRadius=n,this._slices=o,this._numberOfVerticalLines=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}_.packedLength=6,_.pack=function(t,e,i){return i=s.defaultValue(i,0),e[i++]=t._length,e[i++]=t._topRadius,e[i++]=t._bottomRadius,e[i++]=t._slices,e[i++]=t._numberOfVerticalLines,e[i]=s.defaultValue(t._offsetAttribute,-1),e};const h={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};return _.unpack=function(t,e,i){e=s.defaultValue(e,0);const n=t[e++],o=t[e++],r=t[e++],a=t[e++],u=t[e++],f=t[e];return s.defined(i)?(i._length=n,i._topRadius=o,i._bottomRadius=r,i._slices=a,i._numberOfVerticalLines=u,i._offsetAttribute=-1===f?void 0:f,i):(h.length=n,h.topRadius=o,h.bottomRadius=r,h.slices=a,h.numberOfVerticalLines=u,h.offsetAttribute=-1===f?void 0:f,new _(h))},_.createGeometry=function(o){let d=o._length;const l=o._topRadius,b=o._bottomRadius,m=o._slices,p=o._numberOfVerticalLines;if(d<=0||l<0||b<0||0===l&&0===b)return;const _=2*m,h=a.CylinderGeometryLibrary.computePositions(d,l,b,m,!1);let A,R=2*m;if(p>0){const t=Math.min(p,m);A=Math.round(m/t),R+=t}const G=c.IndexDatatype.createTypedArray(_,2*R);let O,V=0;for(O=0;O<m-1;O++)G[V++]=O,G[V++]=O+1,G[V++]=O+m,G[V++]=O+1+m;if(G[V++]=m-1,G[V++]=0,G[V++]=m+m-1,G[V++]=m,p>0)for(O=0;O<m;O+=A)G[V++]=O,G[V++]=O+m;const L=new f.GeometryAttributes;L.position=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:h}),y.x=.5*d,y.y=Math.max(b,l);const g=new e.BoundingSphere(n.Cartesian3.ZERO,i.Cartesian2.magnitude(y));if(s.defined(o._offsetAttribute)){d=h.length;const e=new Uint8Array(d/3),i=o._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;t.arrayFill(e,i),L.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new u.Geometry({attributes:L,indices:G,primitiveType:u.PrimitiveType.LINES,boundingSphere:g,offsetAttribute:o._offsetAttribute})},function(t,e){return s.defined(e)&&(t=_.unpack(t,e)),_.createGeometry(t)}}));
