define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./ArcType-fc72c06c","./GeometryOffsetAttribute-8c5e10db","./BoundingRectangle-3faabee8","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./EllipsoidGeodesic-52fe8ffa","./EllipsoidTangentPlane-6354c9aa","./GeometryAttribute-8f0cc508","./GeometryInstance-57a5edd8","./GeometryPipeline-1ba2ded0","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonGeometryLibrary-0ef79c97","./PolygonPipeline-ef9e08dd","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./AttributeCompression-cf8328fe","./EncodedCartesian3-e203d8be","./arrayRemoveDuplicates-4bbe2c1f","./EllipsoidRhumbLine-6fa5d271","./GeometryAttributes-32b29525"],(function(e,t,o,i,n,r,a,s,l,c,u,p,m,y,g,d,h,f,b,_,P,x,C,w,T,I,A,E,v,G,O){"use strict";const V=new t.Cartographic,F=new t.Cartographic;function D(e,t,o,i){const n=i.cartesianToCartographic(e,V).height,r=i.cartesianToCartographic(t,F);r.height=n,i.cartographicToCartesian(r,t);const a=i.cartesianToCartographic(o,F);a.height=n-100,i.cartographicToCartesian(a,o)}const L=new n.BoundingRectangle,N=new s.Cartesian3,H=new s.Cartesian3,R=new s.Cartesian3,M=new s.Cartesian3,S=new s.Cartesian3,B=new s.Cartesian3;let k=new s.Cartesian3,z=new s.Cartesian3,W=new s.Cartesian3;const Y=new a.Cartesian2,U=new a.Cartesian2,j=new s.Cartesian3,Q=new r.Quaternion,q=new s.Matrix3,K=new s.Matrix3;function Z(t){const o=t.vertexFormat,n=t.geometry,l=t.shadowVolume,u=n.attributes.position.values;let p=u.length;const y=t.wall,g=t.top||y,d=t.bottom||y;if(o.st||o.normal||o.tangent||o.bitangent||l){const e=t.boundingRectangle,i=t.tangentPlane,f=t.ellipsoid,b=t.stRotation,_=t.perPositionHeight,P=Y;P.x=e.x,P.y=e.y;const x=o.st?new Float32Array(p/3*2):void 0;let C;o.normal&&(C=_&&g&&!y?n.attributes.normal.values:new Float32Array(p));const w=o.tangent?new Float32Array(p):void 0,T=o.bitangent?new Float32Array(p):void 0,I=l?new Float32Array(p):void 0;let A=0,E=0,v=H,G=R,O=M,V=!0,F=q,L=K;if(0!==b){let e=r.Quaternion.fromAxisAngle(i._plane.normal,b,Q);F=s.Matrix3.fromQuaternion(e,F),e=r.Quaternion.fromAxisAngle(i._plane.normal,-b,Q),L=s.Matrix3.fromQuaternion(e,L)}else F=s.Matrix3.clone(s.Matrix3.IDENTITY,F),L=s.Matrix3.clone(s.Matrix3.IDENTITY,L);let Z=0,J=0;g&&d&&(Z=p/2,J=p/3,p/=2);for(let n=0;n<p;n+=3){const r=s.Cartesian3.fromArray(u,n,j);if(o.st){let t=s.Matrix3.multiplyByVector(F,r,N);t=f.scaleToGeodeticSurface(t,t);const o=i.projectPointOntoPlane(t,U);a.Cartesian2.subtract(o,P,o);const n=h.CesiumMath.clamp(o.x/e.width,0,1),l=h.CesiumMath.clamp(o.y/e.height,0,1);d&&(x[A+J]=n,x[A+1+J]=l),g&&(x[A]=n,x[A+1]=l),A+=2}if(o.normal||o.tangent||o.bitangent||l){const e=E+1,i=E+2;if(y){if(n+3<p){const e=s.Cartesian3.fromArray(u,n+3,S);if(V){const t=s.Cartesian3.fromArray(u,n+p,B);_&&D(r,e,t,f),s.Cartesian3.subtract(e,r,e),s.Cartesian3.subtract(t,r,t),v=s.Cartesian3.normalize(s.Cartesian3.cross(t,e,v),v),V=!1}s.Cartesian3.equalsEpsilon(e,r,h.CesiumMath.EPSILON10)&&(V=!0)}(o.tangent||o.bitangent)&&(O=f.geodeticSurfaceNormal(r,O),o.tangent&&(G=s.Cartesian3.normalize(s.Cartesian3.cross(O,v,G),G)))}else v=f.geodeticSurfaceNormal(r,v),(o.tangent||o.bitangent)&&(_&&(k=s.Cartesian3.fromArray(C,E,k),z=s.Cartesian3.cross(s.Cartesian3.UNIT_Z,k,z),z=s.Cartesian3.normalize(s.Matrix3.multiplyByVector(L,z,z),z),o.bitangent&&(W=s.Cartesian3.normalize(s.Cartesian3.cross(k,z,W),W))),G=s.Cartesian3.cross(s.Cartesian3.UNIT_Z,v,G),G=s.Cartesian3.normalize(s.Matrix3.multiplyByVector(L,G,G),G),o.bitangent&&(O=s.Cartesian3.normalize(s.Cartesian3.cross(v,G,O),O)));o.normal&&(t.wall?(C[E+Z]=v.x,C[e+Z]=v.y,C[i+Z]=v.z):d&&(C[E+Z]=-v.x,C[e+Z]=-v.y,C[i+Z]=-v.z),(g&&!_||y)&&(C[E]=v.x,C[e]=v.y,C[i]=v.z)),l&&(y&&(v=f.geodeticSurfaceNormal(r,v)),I[E+Z]=-v.x,I[e+Z]=-v.y,I[i+Z]=-v.z),o.tangent&&(t.wall?(w[E+Z]=G.x,w[e+Z]=G.y,w[i+Z]=G.z):d&&(w[E+Z]=-G.x,w[e+Z]=-G.y,w[i+Z]=-G.z),g&&(_?(w[E]=z.x,w[e]=z.y,w[i]=z.z):(w[E]=G.x,w[e]=G.y,w[i]=G.z))),o.bitangent&&(d&&(T[E+Z]=O.x,T[e+Z]=O.y,T[i+Z]=O.z),g&&(_?(T[E]=W.x,T[e]=W.y,T[i]=W.z):(T[E]=O.x,T[e]=O.y,T[i]=O.z))),E+=3}}o.st&&(n.attributes.st=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:x})),o.normal&&(n.attributes.normal=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),o.tangent&&(n.attributes.tangent=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),o.bitangent&&(n.attributes.bitangent=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),l&&(n.attributes.extrudeDirection=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I}))}if(t.extrude&&e.defined(t.offsetAttribute)){const e=u.length/3;let o=new Uint8Array(e);if(t.offsetAttribute===i.GeometryOffsetAttribute.TOP)g&&d||y?o=i.arrayFill(o,1,0,e/2):g&&(o=i.arrayFill(o,1));else{const e=t.offsetAttribute===i.GeometryOffsetAttribute.NONE?0:1;o=i.arrayFill(o,e)}n.attributes.applyOffset=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}return n}const J=new t.Cartographic,X=new t.Cartographic,$={westOverIDL:0,eastOverIDL:0};let ee=new u.EllipsoidGeodesic;function te(t,i,n,r,s){if(s=e.defaultValue(s,new a.Rectangle),!e.defined(t)||t.length<3)return s.west=0,s.north=0,s.south=0,s.east=0,s;if(n===o.ArcType.RHUMB)return a.Rectangle.fromCartesianArray(t,i,s);ee.ellipsoid.equals(i)||(ee=new u.EllipsoidGeodesic(void 0,void 0,i)),s.west=Number.POSITIVE_INFINITY,s.east=Number.NEGATIVE_INFINITY,s.south=Number.POSITIVE_INFINITY,s.north=Number.NEGATIVE_INFINITY,$.westOverIDL=Number.POSITIVE_INFINITY,$.eastOverIDL=Number.NEGATIVE_INFINITY;const l=1/h.CesiumMath.chordLength(r,i.maximumRadius),c=t.length;let p,m=i.cartesianToCartographic(t[0],X),y=J;for(let e=1;e<c;e++)p=y,y=m,m=i.cartesianToCartographic(t[e],p),ee.setEndPoints(y,m),ie(ee,l,s,$);return p=y,y=m,m=i.cartesianToCartographic(t[0],p),ee.setEndPoints(y,m),ie(ee,l,s,$),s.east-s.west>$.eastOverIDL-$.westOverIDL&&(s.west=$.westOverIDL,s.east=$.eastOverIDL,s.east>h.CesiumMath.PI&&(s.east=s.east-h.CesiumMath.TWO_PI),s.west>h.CesiumMath.PI&&(s.west=s.west-h.CesiumMath.TWO_PI)),s}const oe=new t.Cartographic;function ie(e,t,o,i){const n=e.surfaceDistance,r=Math.ceil(n*t),a=r>0?n/(r-1):Number.POSITIVE_INFINITY;let s=0;for(let t=0;t<r;t++){const t=e.interpolateUsingSurfaceDistance(s,oe);s+=a;const n=t.longitude,r=t.latitude;o.west=Math.min(o.west,n),o.east=Math.max(o.east,n),o.south=Math.min(o.south,r),o.north=Math.max(o.north,r);const l=n>=0?n:n+h.CesiumMath.TWO_PI;i.westOverIDL=Math.min(i.westOverIDL,l),i.eastOverIDL=Math.max(i.eastOverIDL,l)}}const ne=[];function re(e,t,o,i,n,r,a,s,l){const c={walls:[]};let u;if(r||a){const i=f.PolygonGeometryLibrary.createGeometryFromPositions(e,t,o,n,s,l),p=i.attributes.position.values,m=i.indices;let g,h;if(r&&a){const e=p.concat(p);g=e.length/3,h=d.IndexDatatype.createTypedArray(g,2*m.length),h.set(m);const t=m.length,o=g/2;for(u=0;u<t;u+=3){const e=h[u]+o,i=h[u+1]+o,n=h[u+2]+o;h[u+t]=n,h[u+1+t]=i,h[u+2+t]=e}if(i.attributes.position.values=e,n&&s.normal){const t=i.attributes.normal.values;i.attributes.normal.values=new Float32Array(e.length),i.attributes.normal.values.set(t)}i.indices=h}else if(a){for(g=p.length/3,h=d.IndexDatatype.createTypedArray(g,m.length),u=0;u<m.length;u+=3)h[u]=m[u+2],h[u+1]=m[u+1],h[u+2]=m[u];i.indices=h}c.topAndBottom=new y.GeometryInstance({geometry:i})}let m=i.outerRing,g=p.EllipsoidTangentPlane.fromPoints(m,e),h=g.projectPointsOntoPlane(m,ne),_=b.PolygonPipeline.computeWindingOrder2D(h);_===b.WindingOrder.CLOCKWISE&&(m=m.slice().reverse());let P=f.PolygonGeometryLibrary.computeWallGeometry(m,e,o,n,l);c.walls.push(new y.GeometryInstance({geometry:P}));const x=i.holes;for(u=0;u<x.length;u++){let t=x[u];g=p.EllipsoidTangentPlane.fromPoints(t,e),h=g.projectPointsOntoPlane(t,ne),_=b.PolygonPipeline.computeWindingOrder2D(h),_===b.WindingOrder.COUNTER_CLOCKWISE&&(t=t.slice().reverse()),P=f.PolygonGeometryLibrary.computeWallGeometry(t,e,o,n,l),c.walls.push(new y.GeometryInstance({geometry:P}))}return c}function ae(i){const n=i.polygonHierarchy,r=e.defaultValue(i.vertexFormat,_.VertexFormat.DEFAULT),a=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84),s=e.defaultValue(i.granularity,h.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(i.stRotation,0),c=e.defaultValue(i.perPositionHeight,!1),u=c&&e.defined(i.extrudedHeight);let p=e.defaultValue(i.height,0),m=e.defaultValue(i.extrudedHeight,p);if(!u){const e=Math.max(p,m);m=Math.min(p,m),p=e}this._vertexFormat=_.VertexFormat.clone(r),this._ellipsoid=t.Ellipsoid.clone(a),this._granularity=s,this._stRotation=l,this._height=p,this._extrudedHeight=m,this._closeTop=e.defaultValue(i.closeTop,!0),this._closeBottom=e.defaultValue(i.closeBottom,!0),this._polygonHierarchy=n,this._perPositionHeight=c,this._perPositionHeightExtrude=u,this._shadowVolume=e.defaultValue(i.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=i.offsetAttribute,this._arcType=e.defaultValue(i.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this.packedLength=f.PolygonGeometryLibrary.computeHierarchyPackedLength(n)+t.Ellipsoid.packedLength+_.VertexFormat.packedLength+12}ae.fromPositions=function(t){return new ae({polygonHierarchy:{positions:(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType})},ae.pack=function(o,i,n){return n=e.defaultValue(n,0),n=f.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,i,n),t.Ellipsoid.pack(o._ellipsoid,i,n),n+=t.Ellipsoid.packedLength,_.VertexFormat.pack(o._vertexFormat,i,n),n+=_.VertexFormat.packedLength,i[n++]=o._height,i[n++]=o._extrudedHeight,i[n++]=o._granularity,i[n++]=o._stRotation,i[n++]=o._perPositionHeightExtrude?1:0,i[n++]=o._perPositionHeight?1:0,i[n++]=o._closeTop?1:0,i[n++]=o._closeBottom?1:0,i[n++]=o._shadowVolume?1:0,i[n++]=e.defaultValue(o._offsetAttribute,-1),i[n++]=o._arcType,i[n]=o.packedLength,i};const se=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),le=new _.VertexFormat,ce={polygonHierarchy:{}};return ae.unpack=function(o,i,n){i=e.defaultValue(i,0);const r=f.PolygonGeometryLibrary.unpackPolygonHierarchy(o,i);i=r.startingIndex,delete r.startingIndex;const a=t.Ellipsoid.unpack(o,i,se);i+=t.Ellipsoid.packedLength;const s=_.VertexFormat.unpack(o,i,le);i+=_.VertexFormat.packedLength;const l=o[i++],c=o[i++],u=o[i++],p=o[i++],m=1===o[i++],y=1===o[i++],g=1===o[i++],d=1===o[i++],h=1===o[i++],b=o[i++],P=o[i++],x=o[i];return e.defined(n)||(n=new ae(ce)),n._polygonHierarchy=r,n._ellipsoid=t.Ellipsoid.clone(a,n._ellipsoid),n._vertexFormat=_.VertexFormat.clone(s,n._vertexFormat),n._height=l,n._extrudedHeight=c,n._granularity=u,n._stRotation=p,n._perPositionHeightExtrude=m,n._perPositionHeight=y,n._closeTop=g,n._closeBottom=d,n._shadowVolume=h,n._offsetAttribute=-1===b?void 0:b,n._arcType=P,n.packedLength=x,n},ae.computeRectangle=function(i,n){const r=e.defaultValue(i.granularity,h.CesiumMath.RADIANS_PER_DEGREE),a=e.defaultValue(i.arcType,o.ArcType.GEODESIC),s=i.polygonHierarchy,l=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84);return te(s.positions,l,a,r,n)},ae.createGeometry=function(t){const o=t._vertexFormat,n=t._ellipsoid,a=t._granularity,s=t._stRotation,l=t._polygonHierarchy,u=t._perPositionHeight,_=t._closeTop,P=t._closeBottom,x=t._arcType;let C=l.positions;if(C.length<3)return;const w=p.EllipsoidTangentPlane.fromPoints(C,n),T=f.PolygonGeometryLibrary.polygonsFromHierarchy(l,w.projectPointsOntoPlane.bind(w),!u,n),I=T.hierarchy,A=T.polygons;if(0===I.length)return;C=I[0].outerRing;const E=f.PolygonGeometryLibrary.computeBoundingRectangle(w.plane.normal,w.projectPointOntoPlane.bind(w),C,s,L),v=[],G=t._height,O=t._extrudedHeight,V={perPositionHeight:u,vertexFormat:o,geometry:void 0,tangentPlane:w,boundingRectangle:E,ellipsoid:n,stRotation:s,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:x};let F;if(t._perPositionHeightExtrude||!h.CesiumMath.equalsEpsilon(G,O,0,h.CesiumMath.EPSILON2))for(V.extrude=!0,V.top=_,V.bottom=P,V.shadowVolume=t._shadowVolume,V.offsetAttribute=t._offsetAttribute,F=0;F<A.length;F++){const e=re(n,A[F],a,I[F],u,_,P,o,x);let t;_&&P?(t=e.topAndBottom,V.geometry=f.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,G,O,n,u)):_?(t=e.topAndBottom,t.geometry.attributes.position.values=b.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,G,n,!u),V.geometry=t.geometry):P&&(t=e.topAndBottom,t.geometry.attributes.position.values=b.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,O,n,!0),V.geometry=t.geometry),(_||P)&&(V.wall=!1,t.geometry=Z(V),v.push(t));const i=e.walls;V.wall=!0;for(let e=0;e<i.length;e++){const t=i[e];V.geometry=f.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,G,O,n,u),t.geometry=Z(V),v.push(t)}}else for(F=0;F<A.length;F++){const r=new y.GeometryInstance({geometry:f.PolygonGeometryLibrary.createGeometryFromPositions(n,A[F],a,u,o,x)});if(r.geometry.attributes.position.values=b.PolygonPipeline.scaleToGeodeticHeight(r.geometry.attributes.position.values,G,n,!u),V.geometry=r.geometry,r.geometry=Z(V),e.defined(t._offsetAttribute)){const e=r.geometry.attributes.position.values.length,o=new Uint8Array(e/3),n=t._offsetAttribute===i.GeometryOffsetAttribute.NONE?0:1;i.arrayFill(o,n),r.geometry.attributes.applyOffset=new m.GeometryAttribute({componentDatatype:c.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}v.push(r)}const D=g.GeometryPipeline.combineInstances(v)[0];D.attributes.position.values=new Float64Array(D.attributes.position.values),D.indices=d.IndexDatatype.createTypedArray(D.attributes.position.values.length/3,D.indices);const N=D.attributes,H=r.BoundingSphere.fromVertices(N.position.values);return o.position||delete N.position,new m.Geometry({attributes:N,indices:D.indices,primitiveType:D.primitiveType,boundingSphere:H,offsetAttribute:t._offsetAttribute})},ae.createShadowVolume=function(e,t,o){const i=e._granularity,n=e._ellipsoid,r=t(i,n),a=o(i,n);return new ae({polygonHierarchy:e._polygonHierarchy,ellipsoid:n,stRotation:e._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:a,vertexFormat:_.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(ae.prototype,{rectangle:{get:function(){if(!e.defined(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=te(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return e.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const o=e._ellipsoid,i=e._polygonHierarchy.positions,n=e.rectangle;return m.Geometry._textureCoordinateRotationPoints(i,t,o,n)}(this)),this._textureCoordinateRotationPoints}}}),function(o,i){return e.defined(i)&&(o=ae.unpack(o,i)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),ae.createGeometry(o)}}));
