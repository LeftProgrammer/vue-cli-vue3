define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./defaultValue-81eec7ed","./RuntimeError-8952249c","./Ellipsoid-119327cb","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./VertexFormat-a0b706b0"],(function(t,e,a,n,i,r,o,s,m,u,c,l,f,d){"use strict";const C=new i.Cartesian3,p=new i.Cartesian3,y=new i.Cartesian3,_=new i.Cartesian3,h=new i.Cartesian3,x=new i.Cartesian3(1,1,1),A=Math.cos,b=Math.sin;function k(t){t=o.defaultValue(t,o.defaultValue.EMPTY_OBJECT);const e=o.defaultValue(t.radii,x),a=o.defaultValue(t.innerRadii,e),n=o.defaultValue(t.minimumClock,0),r=o.defaultValue(t.maximumClock,f.CesiumMath.TWO_PI),s=o.defaultValue(t.minimumCone,0),m=o.defaultValue(t.maximumCone,f.CesiumMath.PI),u=Math.round(o.defaultValue(t.stackPartitions,64)),c=Math.round(o.defaultValue(t.slicePartitions,64)),l=o.defaultValue(t.vertexFormat,d.VertexFormat.DEFAULT);this._radii=i.Cartesian3.clone(e),this._innerRadii=i.Cartesian3.clone(a),this._minimumClock=n,this._maximumClock=r,this._minimumCone=s,this._maximumCone=m,this._stackPartitions=u,this._slicePartitions=c,this._vertexFormat=d.VertexFormat.clone(l),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}k.packedLength=2*i.Cartesian3.packedLength+d.VertexFormat.packedLength+7,k.pack=function(t,e,a){return a=o.defaultValue(a,0),i.Cartesian3.pack(t._radii,e,a),a+=i.Cartesian3.packedLength,i.Cartesian3.pack(t._innerRadii,e,a),a+=i.Cartesian3.packedLength,d.VertexFormat.pack(t._vertexFormat,e,a),a+=d.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=o.defaultValue(t._offsetAttribute,-1),e};const w=new i.Cartesian3,F=new i.Cartesian3,P=new d.VertexFormat,g={radii:w,innerRadii:F,vertexFormat:P,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let v;k.unpack=function(t,e,a){e=o.defaultValue(e,0);const n=i.Cartesian3.unpack(t,e,w);e+=i.Cartesian3.packedLength;const r=i.Cartesian3.unpack(t,e,F);e+=i.Cartesian3.packedLength;const s=d.VertexFormat.unpack(t,e,P);e+=d.VertexFormat.packedLength;const m=t[e++],u=t[e++],c=t[e++],l=t[e++],f=t[e++],C=t[e++],p=t[e];return o.defined(a)?(a._radii=i.Cartesian3.clone(n,a._radii),a._innerRadii=i.Cartesian3.clone(r,a._innerRadii),a._vertexFormat=d.VertexFormat.clone(s,a._vertexFormat),a._minimumClock=m,a._maximumClock=u,a._minimumCone=c,a._maximumCone=l,a._stackPartitions=f,a._slicePartitions=C,a._offsetAttribute=-1===p?void 0:p,a):(g.minimumClock=m,g.maximumClock=u,g.minimumCone=c,g.maximumCone=l,g.stackPartitions=f,g.slicePartitions=C,g.offsetAttribute=-1===p?void 0:p,new k(g))},k.createGeometry=function(t){const s=t._radii;if(s.x<=0||s.y<=0||s.z<=0)return;const d=t._innerRadii;if(d.x<=0||d.y<=0||d.z<=0)return;const x=t._minimumClock,k=t._maximumClock,w=t._minimumCone,F=t._maximumCone,P=t._vertexFormat;let g,v,V=t._slicePartitions+1,M=t._stackPartitions+1;V=Math.round(V*Math.abs(k-x)/f.CesiumMath.TWO_PI),M=Math.round(M*Math.abs(F-w)/f.CesiumMath.PI),V<2&&(V=2),M<2&&(M=2);let T=0;const D=[w],G=[x];for(g=0;g<M;g++)D.push(w+g*(F-w)/(M-1));for(D.push(F),v=0;v<V;v++)G.push(x+v*(k-x)/(V-1));G.push(k);const L=D.length,O=G.length;let E=0,I=1;const z=d.x!==s.x||d.y!==s.y||d.z!==s.z;let N=!1,R=!1,U=!1;z&&(I=2,w>0&&(N=!0,E+=V-1),F<Math.PI&&(R=!0,E+=V-1),(k-x)%f.CesiumMath.TWO_PI?(U=!0,E+=2*(M-1)+1):E+=1);const S=O*L*I,B=new Float64Array(3*S),W=e.arrayFill(new Array(S),!1),Y=e.arrayFill(new Array(S),!1),J=V*M*I,X=6*(J+E+1-(V+M)*I),Z=l.IndexDatatype.createTypedArray(J,X),j=P.normal?new Float32Array(3*S):void 0,q=P.tangent?new Float32Array(3*S):void 0,H=P.bitangent?new Float32Array(3*S):void 0,K=P.st?new Float32Array(2*S):void 0,Q=new Array(L),$=new Array(L);for(g=0;g<L;g++)Q[g]=b(D[g]),$[g]=A(D[g]);const tt=new Array(O),et=new Array(O);for(v=0;v<O;v++)et[v]=A(G[v]),tt[v]=b(G[v]);for(g=0;g<L;g++)for(v=0;v<O;v++)B[T++]=s.x*Q[g]*et[v],B[T++]=s.y*Q[g]*tt[v],B[T++]=s.z*$[g];let at,nt,it,rt,ot=S/2;if(z)for(g=0;g<L;g++)for(v=0;v<O;v++)B[T++]=d.x*Q[g]*et[v],B[T++]=d.y*Q[g]*tt[v],B[T++]=d.z*$[g],W[ot]=!0,g>0&&g!==L-1&&0!==v&&v!==O-1&&(Y[ot]=!0),ot++;for(T=0,g=1;g<L-2;g++)for(at=g*O,nt=(g+1)*O,v=1;v<O-2;v++)Z[T++]=nt+v,Z[T++]=nt+v+1,Z[T++]=at+v+1,Z[T++]=nt+v,Z[T++]=at+v+1,Z[T++]=at+v;if(z){const t=L*O;for(g=1;g<L-2;g++)for(at=t+g*O,nt=t+(g+1)*O,v=1;v<O-2;v++)Z[T++]=nt+v,Z[T++]=at+v,Z[T++]=at+v+1,Z[T++]=nt+v,Z[T++]=at+v+1,Z[T++]=nt+v+1}if(z){if(N)for(rt=L*O,g=1;g<O-2;g++)Z[T++]=g,Z[T++]=g+1,Z[T++]=rt+g+1,Z[T++]=g,Z[T++]=rt+g+1,Z[T++]=rt+g;if(R)for(it=L*O-O,rt=L*O*I-O,g=1;g<O-2;g++)Z[T++]=it+g+1,Z[T++]=it+g,Z[T++]=rt+g,Z[T++]=it+g+1,Z[T++]=rt+g,Z[T++]=rt+g+1}if(U){for(g=1;g<L-2;g++)rt=O*L+O*g,it=O*g,Z[T++]=rt,Z[T++]=it+O,Z[T++]=it,Z[T++]=rt,Z[T++]=rt+O,Z[T++]=it+O;for(g=1;g<L-2;g++)rt=O*L+O*(g+1)-1,it=O*(g+1)-1,Z[T++]=it+O,Z[T++]=rt,Z[T++]=it,Z[T++]=it+O,Z[T++]=rt+O,Z[T++]=rt}const st=new c.GeometryAttributes;P.position&&(st.position=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:B}));let mt=0,ut=0,ct=0,lt=0;const ft=S/2;let dt;const Ct=m.Ellipsoid.fromCartesian3(s),pt=m.Ellipsoid.fromCartesian3(d);if(P.st||P.normal||P.tangent||P.bitangent){for(g=0;g<S;g++){dt=W[g]?pt:Ct;const t=i.Cartesian3.fromArray(B,3*g,C),e=dt.geodeticSurfaceNormal(t,p);if(Y[g]&&i.Cartesian3.negate(e,e),P.st){const t=n.Cartesian2.negate(e,h);K[mt++]=Math.atan2(t.y,t.x)/f.CesiumMath.TWO_PI+.5,K[mt++]=Math.asin(e.z)/Math.PI+.5}if(P.normal&&(j[ut++]=e.x,j[ut++]=e.y,j[ut++]=e.z),P.tangent||P.bitangent){const t=y;let a,n=0;if(W[g]&&(n=ft),a=!N&&g>=n&&g<n+2*O?i.Cartesian3.UNIT_X:i.Cartesian3.UNIT_Z,i.Cartesian3.cross(a,e,t),i.Cartesian3.normalize(t,t),P.tangent&&(q[ct++]=t.x,q[ct++]=t.y,q[ct++]=t.z),P.bitangent){const a=i.Cartesian3.cross(e,t,_);i.Cartesian3.normalize(a,a),H[lt++]=a.x,H[lt++]=a.y,H[lt++]=a.z}}}P.st&&(st.st=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})),P.normal&&(st.normal=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})),P.tangent&&(st.tangent=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:q})),P.bitangent&&(st.bitangent=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:H}))}if(o.defined(t._offsetAttribute)){const a=B.length,n=new Uint8Array(a/3),i=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(n,i),st.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new u.Geometry({attributes:st,indices:Z,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:a.BoundingSphere.fromEllipsoid(Ct),offsetAttribute:t._offsetAttribute})},k.getUnitEllipsoid=function(){return o.defined(v)||(v=k.createGeometry(new k({radii:new i.Cartesian3(1,1,1),vertexFormat:d.VertexFormat.POSITION_ONLY}))),v},t.EllipsoidGeometry=k}));
