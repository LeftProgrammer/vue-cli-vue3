define(["./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./Ellipsoid-119327cb","./RuntimeError-8952249c","./defaultValue-81eec7ed","./Math-c2b1b304","./ArcType-fc72c06c","./arrayRemoveDuplicates-4bbe2c1f","./ComponentDatatype-c4f4738c","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271","./EncodedCartesian3-e203d8be","./GeometryAttribute-8f0cc508","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./WebMercatorProjection-dd895f93","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636"],(function(e,t,a,n,i,r,s,o,l,c,u,C,p,d,h,g,f,m,w,y){"use strict";function M(a){a=r.defaultValue(a,r.defaultValue.EMPTY_OBJECT),this._ellipsoid=r.defaultValue(a.ellipsoid,n.Ellipsoid.WGS84),this._rectangle=r.defaultValue(a.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=r.defaultValue(a.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=r.defaultValue(a.numberOfLevelZeroTilesY,1)}Object.defineProperties(M.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),M.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},M.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},M.prototype.rectangleToNativeRectangle=function(e,a){const n=s.CesiumMath.toDegrees(e.west),i=s.CesiumMath.toDegrees(e.south),o=s.CesiumMath.toDegrees(e.east),l=s.CesiumMath.toDegrees(e.north);return r.defined(a)?(a.west=n,a.south=i,a.east=o,a.north=l,a):new t.Rectangle(n,i,o,l)},M.prototype.tileXYToNativeRectangle=function(e,t,a,n){const i=this.tileXYToRectangle(e,t,a,n);return i.west=s.CesiumMath.toDegrees(i.west),i.south=s.CesiumMath.toDegrees(i.south),i.east=s.CesiumMath.toDegrees(i.east),i.north=s.CesiumMath.toDegrees(i.north),i},M.prototype.tileXYToRectangle=function(e,a,n,i){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(n),l=this.getNumberOfYTilesAtLevel(n),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,p=s.height/l,d=s.north-a*p,h=s.north-(a+1)*p;return r.defined(i)||(i=new t.Rectangle(u,h,C,d)),i.west=u,i.south=h,i.east=C,i.north=d,i},M.prototype.positionToTileXY=function(e,a,n){const i=this._rectangle;if(!t.Rectangle.contains(i,e))return;const o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=i.width/o,u=i.height/l;let C=e.longitude;i.east<i.west&&(C+=s.CesiumMath.TWO_PI);let p=(C-i.west)/c|0;p>=o&&(p=o-1);let d=(i.north-e.latitude)/u|0;return d>=l&&(d=l-1),r.defined(n)?(n.x=p,n.y=d,n):new t.Cartesian2(p,d)};const T=new a.Cartesian3,E=new a.Cartesian3,_=new n.Cartographic,b=new a.Cartesian3,O=new a.Cartesian3,P=new e.BoundingSphere,A=new M,k=[new n.Cartographic,new n.Cartographic,new n.Cartographic,new n.Cartographic],L=new t.Cartesian2,S={};function x(e){n.Cartographic.fromRadians(e.east,e.north,0,k[0]),n.Cartographic.fromRadians(e.west,e.north,0,k[1]),n.Cartographic.fromRadians(e.east,e.south,0,k[2]),n.Cartographic.fromRadians(e.west,e.south,0,k[3]);let t=0,a=0,i=0,r=0;const s=S._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=k[t];if(A.positionToTileXY(a,o,L),0===t)i=L.x,r=L.y;else if(i!==L.x||r!==L.y){e=!0;break}}if(e)break;t=i,a=r}if(0!==o)return{x:t,y:a,level:o>s?s:o-1}}S.initialize=function(){let t=S._initPromise;return r.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){S._terrainHeights=e})),S._initPromise=t),t},S.getMinimumMaximumHeights=function(e,i){i=r.defaultValue(i,n.Ellipsoid.WGS84);const s=x(e);let o=S._defaultMinTerrainHeight,l=S._defaultMaxTerrainHeight;if(r.defined(s)){const n=`${s.level}-${s.x}-${s.y}`,c=S._terrainHeights[n];r.defined(c)&&(o=c[0],l=c[1]),i.cartographicToCartesian(t.Rectangle.northeast(e,_),T),i.cartographicToCartesian(t.Rectangle.southwest(e,_),E),a.Cartesian3.midpoint(E,T,b);const u=i.scaleToGeodeticSurface(b,O);if(r.defined(u)){const e=a.Cartesian3.distance(b,u);o=Math.min(o,-e)}else o=S._defaultMinTerrainHeight}return o=Math.max(S._defaultMinTerrainHeight,o),{minimumTerrainHeight:o,maximumTerrainHeight:l}},S.getBoundingSphere=function(t,a){a=r.defaultValue(a,n.Ellipsoid.WGS84);const i=x(t);let s=S._defaultMaxTerrainHeight;if(r.defined(i)){const e=`${i.level}-${i.x}-${i.y}`,t=S._terrainHeights[e];r.defined(t)&&(s=t[1])}const o=e.BoundingSphere.fromRectangle3D(t,a,0);return e.BoundingSphere.fromRectangle3D(t,a,s,P),e.BoundingSphere.union(o,P,o)},S._terrainHeightsMaxLevel=6,S._defaultMaxTerrainHeight=9e3,S._defaultMinTerrainHeight=-1e5,S._terrainHeights=void 0,S._initPromise=void 0,Object.defineProperties(S,{initialized:{get:function(){return r.defined(S._terrainHeights)}}});const I=[e.GeographicProjection,f.WebMercatorProjection],N=I.length,R=Math.cos(s.CesiumMath.toRadians(30)),D=Math.cos(s.CesiumMath.toRadians(150));function v(e){const t=(e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT)).positions;this.width=r.defaultValue(e.width,1),this._positions=t,this.granularity=r.defaultValue(e.granularity,9999),this.loop=r.defaultValue(e.loop,!1),this.arcType=r.defaultValue(e.arcType,o.ArcType.GEODESIC),this._ellipsoid=n.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(v.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+n.Ellipsoid.packedLength+1+1}}}),v.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<N;e++)if(t instanceof I[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const z=new a.Cartesian3,H=new a.Cartesian3,j=new a.Cartesian3;function B(e,t,n,i,r){const s=W(i,e,0,z),o=W(i,e,n,H),l=W(i,t,0,j),c=U(o,s,H),u=U(l,s,j);return a.Cartesian3.cross(u,c,r),a.Cartesian3.normalize(r,r)}const V=new n.Cartographic,G=new a.Cartesian3,Y=new a.Cartesian3,F=new a.Cartesian3;function q(e,t,n,i,r,s,l,c,p,d,h){if(0===r)return;let g;s===o.ArcType.GEODESIC?g=new u.EllipsoidGeodesic(e,t,l):s===o.ArcType.RHUMB&&(g=new C.EllipsoidRhumbLine(e,t,l));const f=g.surfaceDistance;if(f<r)return;const m=B(e,t,i,l,F),w=Math.ceil(f/r),y=f/w;let M=y;const T=w-1;let E=c.length;for(let e=0;e<T;e++){const e=g.interpolateUsingSurfaceDistance(M,V),t=W(l,e,n,G),r=W(l,e,i,Y);a.Cartesian3.pack(m,c,E),a.Cartesian3.pack(t,p,E),a.Cartesian3.pack(r,d,E),h.push(e.latitude),h.push(e.longitude),E+=3,M+=y}}const X=new n.Cartographic;function W(e,t,a,i){return n.Cartographic.clone(t,X),X.height=a,n.Cartographic.toCartesian(X,e,i)}function U(e,t,n){return a.Cartesian3.subtract(e,t,n),a.Cartesian3.normalize(n,n),n}function Z(e,t,n,i){return i=U(e,t,i),i=a.Cartesian3.cross(i,n,i),i=a.Cartesian3.normalize(i,i),i=a.Cartesian3.cross(n,i,i)}v.pack=function(e,t,i){let s=r.defaultValue(i,0);const o=e._positions,l=o.length;t[s++]=l;for(let e=0;e<l;++e){const n=o[e];a.Cartesian3.pack(n,t,s),s+=3}return t[s++]=e.granularity,t[s++]=e.loop?1:0,t[s++]=e.arcType,n.Ellipsoid.pack(e._ellipsoid,t,s),s+=n.Ellipsoid.packedLength,t[s++]=e._projectionIndex,t[s++]=e._scene3DOnly?1:0,t},v.unpack=function(e,t,i){let s=r.defaultValue(t,0);const o=e[s++],l=new Array(o);for(let t=0;t<o;t++)l[t]=a.Cartesian3.unpack(e,s),s+=3;const c=e[s++],u=1===e[s++],C=e[s++],p=n.Ellipsoid.unpack(e,s);s+=n.Ellipsoid.packedLength;const d=e[s++],h=1===e[s++];return r.defined(i)||(i=new v({positions:l})),i._positions=l,i.granularity=c,i.loop=u,i.arcType=C,i._ellipsoid=p,i._projectionIndex=d,i._scene3DOnly=h,i};const $=new a.Cartesian3,J=new a.Cartesian3,Q=new a.Cartesian3,K=new a.Cartesian3;function ee(e,t,n,i,r){const o=U(n,t,K),l=Z(e,t,o,$),c=Z(i,t,o,J);if(s.CesiumMath.equalsEpsilon(a.Cartesian3.dot(l,c),-1,s.CesiumMath.EPSILON5))return r=a.Cartesian3.cross(o,l,r),r=a.Cartesian3.normalize(r,r);r=a.Cartesian3.add(c,l,r),r=a.Cartesian3.normalize(r,r);const u=a.Cartesian3.cross(o,r,Q);return a.Cartesian3.dot(c,u)<0&&(r=a.Cartesian3.negate(r,r)),r}const te=g.Plane.fromPointNormal(a.Cartesian3.ZERO,a.Cartesian3.UNIT_Y),ae=new a.Cartesian3,ne=new a.Cartesian3,ie=new a.Cartesian3,re=new a.Cartesian3,se=new a.Cartesian3,oe=new a.Cartesian3,le=new n.Cartographic,ce=new n.Cartographic,ue=new n.Cartographic;v.createGeometry=function(i){const u=!i._scene3DOnly;let g=i.loop;const f=i._ellipsoid,m=i.granularity,w=i.arcType,y=new I[i._projectionIndex](f),M=1e3;let T,E;const _=i._positions,b=_.length;let O,P,A,k;2===b&&(g=!1);const L=new C.EllipsoidRhumbLine(void 0,void 0,f);let x,N,D;const v=[_[0]];for(E=0;E<b-1;E++)O=_[E],P=_[E+1],x=h.IntersectionTests.lineSegmentPlane(O,P,te,oe),!r.defined(x)||a.Cartesian3.equalsEpsilon(x,O,s.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(x,P,s.CesiumMath.EPSILON7)||(i.arcType===o.ArcType.GEODESIC?v.push(a.Cartesian3.clone(x)):i.arcType===o.ArcType.RHUMB&&(D=f.cartesianToCartographic(x,le).longitude,A=f.cartesianToCartographic(O,le),k=f.cartesianToCartographic(P,ce),L.setEndPoints(A,k),N=L.findIntersectionWithLongitude(D,ue),x=f.cartographicToCartesian(N,oe),!r.defined(x)||a.Cartesian3.equalsEpsilon(x,O,s.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(x,P,s.CesiumMath.EPSILON7)||v.push(a.Cartesian3.clone(x)))),v.push(P);g&&(O=_[b-1],P=_[0],x=h.IntersectionTests.lineSegmentPlane(O,P,te,oe),!r.defined(x)||a.Cartesian3.equalsEpsilon(x,O,s.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(x,P,s.CesiumMath.EPSILON7)||(i.arcType===o.ArcType.GEODESIC?v.push(a.Cartesian3.clone(x)):i.arcType===o.ArcType.RHUMB&&(D=f.cartesianToCartographic(x,le).longitude,A=f.cartesianToCartographic(O,le),k=f.cartesianToCartographic(P,ce),L.setEndPoints(A,k),N=L.findIntersectionWithLongitude(D,ue),x=f.cartographicToCartesian(N,oe),!r.defined(x)||a.Cartesian3.equalsEpsilon(x,O,s.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(x,P,s.CesiumMath.EPSILON7)||v.push(a.Cartesian3.clone(x)))));let z=v.length,H=new Array(z);for(E=0;E<z;E++){const e=n.Cartographic.fromCartesian(v[E],f);e.height=0,H[E]=e}if(H=l.arrayRemoveDuplicates(H,n.Cartographic.equalsEpsilon),z=H.length,z<2)return;const j=[],V=[],G=[],Y=[];let F=ae,X=ne,Z=ie,$=re,J=se;const Q=H[0],K=H[1];for(F=W(f,H[z-1],0,F),$=W(f,K,0,$),X=W(f,Q,0,X),Z=W(f,Q,M,Z),J=g?ee(F,X,Z,$,J):B(Q,K,M,f,J),a.Cartesian3.pack(J,V,0),a.Cartesian3.pack(X,G,0),a.Cartesian3.pack(Z,Y,0),j.push(Q.latitude),j.push(Q.longitude),q(Q,K,0,M,m,w,f,V,G,Y,j),E=1;E<z-1;++E){F=a.Cartesian3.clone(X,F),X=a.Cartesian3.clone($,X);const e=H[E];W(f,e,M,Z),W(f,H[E+1],0,$),ee(F,X,Z,$,J),T=V.length,a.Cartesian3.pack(J,V,T),a.Cartesian3.pack(X,G,T),a.Cartesian3.pack(Z,Y,T),j.push(e.latitude),j.push(e.longitude),q(H[E],H[E+1],0,M,m,w,f,V,G,Y,j)}const Ce=H[z-1],pe=H[z-2];if(X=W(f,Ce,0,X),Z=W(f,Ce,M,Z),g){const e=H[0];F=W(f,pe,0,F),$=W(f,e,0,$),J=ee(F,X,Z,$,J)}else J=B(pe,Ce,M,f,J);if(T=V.length,a.Cartesian3.pack(J,V,T),a.Cartesian3.pack(X,G,T),a.Cartesian3.pack(Z,Y,T),j.push(Ce.latitude),j.push(Ce.longitude),g){for(q(Ce,Q,0,M,m,w,f,V,G,Y,j),T=V.length,E=0;E<3;++E)V[T+E]=V[E],G[T+E]=G[E],Y[T+E]=Y[E];j.push(Q.latitude),j.push(Q.longitude)}return function(n,i,r,o,l,u,C){let h,g;const f=i._ellipsoid,m=r.length/3-1,w=8*m,y=4*w,M=36*m,T=w>65535?new Uint32Array(M):new Uint16Array(M),E=new Float64Array(3*w),_=new Float32Array(y),b=new Float32Array(y),O=new Float32Array(y),P=new Float32Array(y),A=new Float32Array(y);let k,L,x,I;C&&(k=new Float32Array(y),L=new Float32Array(y),x=new Float32Array(y),I=new Float32Array(2*w));const N=u.length/2;let D=0;const v=Oe;v.height=0;const z=Pe;z.height=0;let H=Ae,j=ke;if(C)for(g=0,h=1;h<N;h++)v.latitude=u[g],v.longitude=u[g+1],z.latitude=u[g+2],z.longitude=u[g+3],H=i.project(v,H),j=i.project(z,j),D+=a.Cartesian3.distance(H,j),g+=2;const B=o.length/3;j=a.Cartesian3.unpack(o,0,j);let V,G=0;for(g=3,h=1;h<B;h++)H=a.Cartesian3.clone(j,H),j=a.Cartesian3.unpack(o,g,j),G+=a.Cartesian3.distance(H,j),g+=3;g=3;let Y=0,F=0,q=0,X=0,W=!1,Z=a.Cartesian3.unpack(r,0,Se),$=a.Cartesian3.unpack(o,0,ke),J=a.Cartesian3.unpack(l,0,Ie);if(n){he(J,a.Cartesian3.unpack(r,r.length-6,Le),Z,$)&&(J=a.Cartesian3.negate(J,J))}let Q=0,K=0,ee=0;for(h=0;h<m;h++){const e=a.Cartesian3.clone(Z,Le),n=a.Cartesian3.clone($,Ae);let c,d,h,m,w=a.Cartesian3.clone(J,xe);if(W&&(w=a.Cartesian3.negate(w,w)),Z=a.Cartesian3.unpack(r,g,Se),$=a.Cartesian3.unpack(o,g,ke),J=a.Cartesian3.unpack(l,g,Ie),W=he(J,e,Z,$),v.latitude=u[Y],v.longitude=u[Y+1],z.latitude=u[Y+2],z.longitude=u[Y+3],C){const e=be(v,z);c=i.project(v,je),d=i.project(z,Be);const t=U(d,c,Je);t.y=Math.abs(t.y),h=Ve,m=Ge,0===e||a.Cartesian3.dot(t,a.Cartesian3.UNIT_Y)>R?(h=we(i,v,w,c,Ve),m=we(i,z,J,d,Ge)):1===e?(m=we(i,z,J,d,Ge),h.x=0,h.y=s.CesiumMath.sign(v.longitude-Math.abs(z.longitude)),h.z=0):(h=we(i,v,w,c,Ve),m.x=0,m.y=s.CesiumMath.sign(v.longitude-z.longitude),m.z=0)}const y=a.Cartesian3.distance(n,$),M=p.EncodedCartesian3.fromCartesian(e,Ze),T=a.Cartesian3.subtract(Z,e,Ye),N=a.Cartesian3.normalize(T,Xe);let H=a.Cartesian3.subtract(n,e,Fe);H=a.Cartesian3.normalize(H,H);let j=a.Cartesian3.cross(N,H,Xe);j=a.Cartesian3.normalize(j,j);let B=a.Cartesian3.cross(H,w,We);B=a.Cartesian3.normalize(B,B);let te=a.Cartesian3.subtract($,Z,qe);te=a.Cartesian3.normalize(te,te);let ae=a.Cartesian3.cross(J,te,Ue);ae=a.Cartesian3.normalize(ae,ae);const ne=y/G,ie=Q/G;let re,se,oe,le=0,ce=0,ue=0;if(C){le=a.Cartesian3.distance(c,d),re=p.EncodedCartesian3.fromCartesian(c,$e),se=a.Cartesian3.subtract(d,c,Je),oe=a.Cartesian3.normalize(se,Qe);const e=oe.x;oe.x=oe.y,oe.y=-e,ce=le/D,ue=K/D}for(V=0;V<8;V++){const e=X+4*V,t=F+2*V,n=e+3,i=V<4?1:-1,r=2===V||3===V||6===V||7===V?1:-1;a.Cartesian3.pack(M.high,_,e),_[n]=T.x,a.Cartesian3.pack(M.low,b,e),b[n]=T.y,a.Cartesian3.pack(B,O,e),O[n]=T.z,a.Cartesian3.pack(ae,P,e),P[n]=ne*i,a.Cartesian3.pack(j,A,e);let s=ie*r;0===s&&r<0&&(s=9),A[n]=s,C&&(k[e]=re.high.x,k[e+1]=re.high.y,k[e+2]=re.low.x,k[e+3]=re.low.y,x[e]=-h.y,x[e+1]=h.x,x[e+2]=m.y,x[e+3]=-m.x,L[e]=se.x,L[e+1]=se.y,L[e+2]=oe.x,L[e+3]=oe.y,I[t]=ce*i,s=ue*r,0===s&&r<0&&(s=9),I[t+1]=s)}const Ce=ze,pe=He,de=De,ge=ve,fe=t.Rectangle.fromCartographicArray(Ne,Re),me=S.getMinimumMaximumHeights(fe,f),ye=me.minimumTerrainHeight,Me=me.maximumTerrainHeight;ee+=ye,ee+=Me,Te(e,n,ye,Me,Ce,de),Te(Z,$,ye,Me,pe,ge);let Ee=a.Cartesian3.multiplyByScalar(j,s.CesiumMath.EPSILON5,Ke);a.Cartesian3.add(Ce,Ee,Ce),a.Cartesian3.add(pe,Ee,pe),a.Cartesian3.add(de,Ee,de),a.Cartesian3.add(ge,Ee,ge),_e(Ce,pe),_e(de,ge),a.Cartesian3.pack(Ce,E,q),a.Cartesian3.pack(pe,E,q+3),a.Cartesian3.pack(ge,E,q+6),a.Cartesian3.pack(de,E,q+9),Ee=a.Cartesian3.multiplyByScalar(j,-2*s.CesiumMath.EPSILON5,Ke),a.Cartesian3.add(Ce,Ee,Ce),a.Cartesian3.add(pe,Ee,pe),a.Cartesian3.add(de,Ee,de),a.Cartesian3.add(ge,Ee,ge),_e(Ce,pe),_e(de,ge),a.Cartesian3.pack(Ce,E,q+12),a.Cartesian3.pack(pe,E,q+15),a.Cartesian3.pack(ge,E,q+18),a.Cartesian3.pack(de,E,q+21),Y+=2,g+=3,F+=16,q+=24,X+=32,Q+=y,K+=le}g=0;let te=0;for(h=0;h<m;h++){for(V=0;V<at;V++)T[g+V]=tt[V]+te;te+=8,g+=at}const ae=et;e.BoundingSphere.fromVertices(r,a.Cartesian3.ZERO,3,ae[0]),e.BoundingSphere.fromVertices(o,a.Cartesian3.ZERO,3,ae[1]);const ne=e.BoundingSphere.fromBoundingSpheres(ae);ne.radius+=ee/(2*m);const ie={position:new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:E}),startHiAndForwardOffsetX:nt(_),startLoAndForwardOffsetY:nt(b),startNormalAndForwardOffsetZ:nt(O),endNormalAndTextureCoordinateNormalizationX:nt(P),rightNormalAndTextureCoordinateNormalizationY:nt(A)};C&&(ie.startHiLo2D=nt(k),ie.offsetAndRight2D=nt(L),ie.startEndNormals2D=nt(x),ie.texcoordNormalization2D=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:I}));return new d.Geometry({attributes:ie,indices:T,boundingSphere:ne})}(g,y,G,Y,V,j,u)};const Ce=new a.Cartesian3,pe=new a.Matrix3,de=new e.Quaternion;function he(t,n,i,r){const o=U(i,n,Ce),l=a.Cartesian3.dot(o,t);if(l>R||l<D){const n=U(r,i,K),o=l<D?s.CesiumMath.PI_OVER_TWO:-s.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,de),u=a.Matrix3.fromQuaternion(c,pe);return a.Matrix3.multiplyByVector(u,t,t),!0}return!1}const ge=new n.Cartographic,fe=new a.Cartesian3,me=new a.Cartesian3;function we(e,t,i,r,o){const l=n.Cartographic.toCartesian(t,e._ellipsoid,fe);let c=a.Cartesian3.add(l,i,me),u=!1;const C=e._ellipsoid;let p=C.cartesianToCartographic(c,ge);Math.abs(t.longitude-p.longitude)>s.CesiumMath.PI_OVER_TWO&&(u=!0,c=a.Cartesian3.subtract(l,i,me),p=C.cartesianToCartographic(c,ge)),p.height=0;const d=e.project(p,o);return(o=a.Cartesian3.subtract(d,r,o)).z=0,o=a.Cartesian3.normalize(o,o),u&&a.Cartesian3.negate(o,o),o}const ye=new a.Cartesian3,Me=new a.Cartesian3;function Te(e,t,n,i,r,s){const o=a.Cartesian3.subtract(t,e,ye);a.Cartesian3.normalize(o,o);const l=n-0;let c=a.Cartesian3.multiplyByScalar(o,l,Me);a.Cartesian3.add(e,c,r);const u=i-1e3;c=a.Cartesian3.multiplyByScalar(o,u,Me),a.Cartesian3.add(t,c,s)}const Ee=new a.Cartesian3;function _e(e,t){const n=g.Plane.getPointDistance(te,e),i=g.Plane.getPointDistance(te,t);let r=Ee;s.CesiumMath.equalsEpsilon(n,0,s.CesiumMath.EPSILON2)?(r=U(t,e,r),a.Cartesian3.multiplyByScalar(r,s.CesiumMath.EPSILON2,r),a.Cartesian3.add(e,r,e)):s.CesiumMath.equalsEpsilon(i,0,s.CesiumMath.EPSILON2)&&(r=U(e,t,r),a.Cartesian3.multiplyByScalar(r,s.CesiumMath.EPSILON2,r),a.Cartesian3.add(t,r,t))}function be(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(s.CesiumMath.equalsEpsilon(a,s.CesiumMath.PI,s.CesiumMath.EPSILON11)){const n=s.CesiumMath.sign(t.longitude);return e.longitude=n*(a-s.CesiumMath.EPSILON11),1}if(s.CesiumMath.equalsEpsilon(n,s.CesiumMath.PI,s.CesiumMath.EPSILON11)){const a=s.CesiumMath.sign(e.longitude);return t.longitude=a*(n-s.CesiumMath.EPSILON11),2}return 0}const Oe=new n.Cartographic,Pe=new n.Cartographic,Ae=new a.Cartesian3,ke=new a.Cartesian3,Le=new a.Cartesian3,Se=new a.Cartesian3,xe=new a.Cartesian3,Ie=new a.Cartesian3,Ne=[Oe,Pe],Re=new t.Rectangle,De=new a.Cartesian3,ve=new a.Cartesian3,ze=new a.Cartesian3,He=new a.Cartesian3,je=new a.Cartesian3,Be=new a.Cartesian3,Ve=new a.Cartesian3,Ge=new a.Cartesian3,Ye=new a.Cartesian3,Fe=new a.Cartesian3,qe=new a.Cartesian3,Xe=new a.Cartesian3,We=new a.Cartesian3,Ue=new a.Cartesian3,Ze=new p.EncodedCartesian3,$e=new p.EncodedCartesian3,Je=new a.Cartesian3,Qe=new a.Cartesian3,Ke=new a.Cartesian3,et=[new e.BoundingSphere,new e.BoundingSphere],tt=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],at=tt.length;function nt(e){return new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return v._projectNormal=we,function(e,t){return S.initialize().then((function(){return r.defined(t)&&(e=v.unpack(e,t)),v.createGeometry(e)}))}}));
