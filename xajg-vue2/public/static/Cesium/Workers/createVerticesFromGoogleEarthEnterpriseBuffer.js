define(["./AxisAlignedBoundingBox-ace5a411","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./Ellipsoid-119327cb","./defaultValue-81eec7ed","./TerrainEncoding-0ae22bd9","./Math-c2b1b304","./OrientedBoundingBox-8f892e7f","./RuntimeError-8952249c","./WebMercatorProjection-dd895f93","./createTaskProcessorWorker","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./AttributeCompression-cf8328fe","./ComponentDatatype-c4f4738c","./WebGLConstants-508b9636","./EllipsoidTangentPlane-6354c9aa","./IntersectionTests-4511d2eb","./Plane-f0451b7c"],(function(t,e,n,i,o,a,r,s,c,u,h,l,d,g,m,p,f,I,E,T){"use strict";const C=Uint16Array.BYTES_PER_ELEMENT,M=Int32Array.BYTES_PER_ELEMENT,x=Uint32Array.BYTES_PER_ELEMENT,N=Float32Array.BYTES_PER_ELEMENT,b=Float64Array.BYTES_PER_ELEMENT;function S(t,e,n){n=a.defaultValue(n,s.CesiumMath);const i=t.length;for(let o=0;o<i;++o)if(n.equalsEpsilon(t[o],e,s.CesiumMath.EPSILON12))return o;return-1}const w=new o.Cartographic,B=new i.Cartesian3,P=new i.Cartesian3,A=new i.Cartesian3,y=new i.Matrix4;function R(t,e,r,c,u,h,l,d,g,m,p){const f=d.length;for(let I=0;I<f;++I){const E=d[I],T=E.cartographic,C=E.index,M=t.length,x=T.longitude;let N=T.latitude;N=s.CesiumMath.clamp(N,-s.CesiumMath.PI_OVER_TWO,s.CesiumMath.PI_OVER_TWO);const b=T.height-l.skirtHeight;l.hMin=Math.min(l.hMin,b),o.Cartographic.fromRadians(x,N,b,w),m&&(w.longitude+=g),m?I===f-1?w.latitude+=p:0===I&&(w.latitude-=p):w.latitude+=g;const S=l.ellipsoid.cartographicToCartesian(w);t.push(S),e.push(b),r.push(n.Cartesian2.clone(r[C])),c.length>0&&c.push(c[C]),u.length>0&&u.push(u[C]),i.Matrix4.multiplyByPoint(l.toENU,S,B);const P=l.minimum,A=l.maximum;i.Cartesian3.minimumByComponent(B,P,P),i.Cartesian3.maximumByComponent(B,A,A);const y=l.lastBorderPoint;if(a.defined(y)){const t=y.index;h.push(t,M-1,M,M,C,t)}l.lastBorderPoint=E}}return l((function(l,d){l.ellipsoid=o.Ellipsoid.clone(l.ellipsoid),l.rectangle=n.Rectangle.clone(l.rectangle);const g=function(l,d,g,m,p,f,I,E,T,_,W){let v,F,O,V,Y,H;a.defined(m)?(v=m.west,F=m.south,O=m.east,V=m.north,Y=m.width,H=m.height):(v=s.CesiumMath.toRadians(p.west),F=s.CesiumMath.toRadians(p.south),O=s.CesiumMath.toRadians(p.east),V=s.CesiumMath.toRadians(p.north),Y=s.CesiumMath.toRadians(m.width),H=s.CesiumMath.toRadians(m.height));const U=[F,V],k=[v,O],L=e.Transforms.eastNorthUpToFixedFrame(d,g),j=i.Matrix4.inverseTransformation(L,y);let D,G;T&&(D=h.WebMercatorProjection.geodeticLatitudeToMercatorAngle(F),G=1/(h.WebMercatorProjection.geodeticLatitudeToMercatorAngle(V)-D));const z=1!==f,q=new DataView(l);let J=Number.POSITIVE_INFINITY,K=Number.NEGATIVE_INFINITY;const Q=P;Q.x=Number.POSITIVE_INFINITY,Q.y=Number.POSITIVE_INFINITY,Q.z=Number.POSITIVE_INFINITY;const X=A;X.x=Number.NEGATIVE_INFINITY,X.y=Number.NEGATIVE_INFINITY,X.z=Number.NEGATIVE_INFINITY;let Z,$,tt=0,et=0,nt=0;for($=0;$<4;++$){let t=tt;Z=q.getUint32(t,!0),t+=x;const e=s.CesiumMath.toRadians(180*q.getFloat64(t,!0));t+=b,-1===S(k,e)&&k.push(e);const n=s.CesiumMath.toRadians(180*q.getFloat64(t,!0));t+=b,-1===S(U,n)&&U.push(n),t+=2*b;let i=q.getInt32(t,!0);t+=M,et+=i,i=q.getInt32(t,!0),nt+=3*i,tt+=Z+x}const it=[],ot=[],at=new Array(et),rt=new Array(et),st=new Array(et),ct=T?new Array(et):[],ut=z?new Array(et):[],ht=new Array(nt),lt=[],dt=[],gt=[],mt=[];let pt=0,ft=0;for(tt=0,$=0;$<4;++$){Z=q.getUint32(tt,!0),tt+=x;const t=tt,e=s.CesiumMath.toRadians(180*q.getFloat64(tt,!0));tt+=b;const a=s.CesiumMath.toRadians(180*q.getFloat64(tt,!0));tt+=b;const r=s.CesiumMath.toRadians(180*q.getFloat64(tt,!0)),c=.5*r;tt+=b;const l=s.CesiumMath.toRadians(180*q.getFloat64(tt,!0)),d=.5*l;tt+=b;const m=q.getInt32(tt,!0);tt+=M;const p=q.getInt32(tt,!0);tt+=M,tt+=M;const f=new Array(m);for(let t=0;t<m;++t){const u=e+q.getUint8(tt++)*r;w.longitude=u;const m=a+q.getUint8(tt++)*l;w.latitude=m;let p=q.getFloat32(tt,!0);if(tt+=N,0!==p&&p<W&&(p*=-Math.pow(2,_)),p*=6371010,w.height=p,-1!==S(k,u)||-1!==S(U,m)){const e=S(it,w,o.Cartographic);if(-1!==e){f[t]=ot[e];continue}it.push(o.Cartographic.clone(w)),ot.push(pt)}f[t]=pt,Math.abs(u-v)<c?lt.push({index:pt,cartographic:o.Cartographic.clone(w)}):Math.abs(u-O)<c?gt.push({index:pt,cartographic:o.Cartographic.clone(w)}):Math.abs(m-F)<d?dt.push({index:pt,cartographic:o.Cartographic.clone(w)}):Math.abs(m-V)<d&&mt.push({index:pt,cartographic:o.Cartographic.clone(w)}),J=Math.min(p,J),K=Math.max(p,K),st[pt]=p;const I=g.cartographicToCartesian(w);if(at[pt]=I,T&&(ct[pt]=(h.WebMercatorProjection.geodeticLatitudeToMercatorAngle(m)-D)*G),z){const t=g.geodeticSurfaceNormal(I);ut[pt]=t}i.Matrix4.multiplyByPoint(j,I,B),i.Cartesian3.minimumByComponent(B,Q,Q),i.Cartesian3.maximumByComponent(B,X,X);let E=(u-v)/(O-v);E=s.CesiumMath.clamp(E,0,1);let C=(m-F)/(V-F);C=s.CesiumMath.clamp(C,0,1),rt[pt]=new n.Cartesian2(E,C),++pt}const I=3*p;for(let t=0;t<I;++t,++ft)ht[ft]=f[q.getUint16(tt,!0)],tt+=C;if(Z!==tt-t)throw new u.RuntimeError("Invalid terrain tile.")}at.length=pt,rt.length=pt,st.length=pt,T&&(ct.length=pt);z&&(ut.length=pt);const It=pt,Et=ft,Tt={hMin:J,lastBorderPoint:void 0,skirtHeight:E,toENU:j,ellipsoid:g,minimum:Q,maximum:X};lt.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),dt.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),gt.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),mt.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));const Ct=1e-5;if(R(at,st,rt,ct,ut,ht,Tt,lt,-Ct*Y,!0,-Ct*H),R(at,st,rt,ct,ut,ht,Tt,dt,-Ct*H,!1),R(at,st,rt,ct,ut,ht,Tt,gt,Ct*Y,!0,Ct*H),R(at,st,rt,ct,ut,ht,Tt,mt,Ct*H,!1),lt.length>0&&mt.length>0){const t=lt[0].index,e=It,n=mt[mt.length-1].index,i=at.length-1;ht.push(n,i,e,e,t,n)}et=at.length;const Mt=e.BoundingSphere.fromPoints(at);let xt;a.defined(m)&&(xt=c.OrientedBoundingBox.fromRectangle(m,J,K,g));const Nt=new r.EllipsoidalOccluder(g).computeHorizonCullingPointPossiblyUnderEllipsoid(d,at,J),bt=new t.AxisAlignedBoundingBox(Q,X,d),St=new r.TerrainEncoding(d,bt,Tt.hMin,K,L,!1,T,z,f,I),wt=new Float32Array(et*St.stride);let Bt=0;for(let t=0;t<et;++t)Bt=St.encode(wt,Bt,at[t],rt[t],st[t],void 0,ct[t],ut[t]);const Pt=lt.map((function(t){return t.index})).reverse(),At=dt.map((function(t){return t.index})).reverse(),yt=gt.map((function(t){return t.index})).reverse(),Rt=mt.map((function(t){return t.index})).reverse();return At.unshift(yt[yt.length-1]),At.push(Pt[0]),Rt.unshift(Pt[Pt.length-1]),Rt.push(yt[0]),{vertices:wt,indices:new Uint16Array(ht),maximumHeight:K,minimumHeight:J,encoding:St,boundingSphere3D:Mt,orientedBoundingBox:xt,occludeePointInScaledSpace:Nt,vertexCountWithoutSkirts:It,indexCountWithoutSkirts:Et,westIndicesSouthToNorth:Pt,southIndicesEastToWest:At,eastIndicesNorthToSouth:yt,northIndicesWestToEast:Rt}}(l.buffer,l.relativeToCenter,l.ellipsoid,l.rectangle,l.nativeRectangle,l.exaggeration,l.exaggerationRelativeHeight,l.skirtHeight,l.includeWebMercatorT,l.negativeAltitudeExponentBias,l.negativeElevationThreshold),m=g.vertices;d.push(m.buffer);const p=g.indices;return d.push(p.buffer),{vertices:m.buffer,indices:p.buffer,numberOfAttributes:g.encoding.stride,minimumHeight:g.minimumHeight,maximumHeight:g.maximumHeight,boundingSphere3D:g.boundingSphere3D,orientedBoundingBox:g.orientedBoundingBox,occludeePointInScaledSpace:g.occludeePointInScaledSpace,encoding:g.encoding,vertexCountWithoutSkirts:g.vertexCountWithoutSkirts,indexCountWithoutSkirts:g.indexCountWithoutSkirts,westIndicesSouthToNorth:g.westIndicesSouthToNorth,southIndicesEastToWest:g.southIndicesEastToWest,eastIndicesNorthToSouth:g.eastIndicesNorthToSouth,northIndicesWestToEast:g.northIndicesWestToEast}}))}));
