define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./Transforms-51e2663f","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./RuntimeError-8952249c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./WallGeometryLibrary-2f7b98cd","./Matrix2-115e2170","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./arrayRemoveDuplicates-4bbe2c1f","./PolylinePipeline-cfd2c1cf","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271","./IntersectionTests-4511d2eb","./Plane-f0451b7c"],(function(e,i,t,n,o,a,s,r,l,m,d,u,c,p,f,h,g,y,_,E,b){"use strict";const H=new n.Cartesian3,C=new n.Cartesian3;function A(t){const o=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,a=t.maximumHeights,s=t.minimumHeights,r=e.defaultValue(t.granularity,m.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84);this._positions=o,this._minimumHeights=s,this._maximumHeights=a,this._granularity=r,this._ellipsoid=i.Ellipsoid.clone(l),this._workerName="createWallOutlineGeometry";let d=1+o.length*n.Cartesian3.packedLength+2;e.defined(s)&&(d+=s.length),e.defined(a)&&(d+=a.length),this.packedLength=d+i.Ellipsoid.packedLength+1}A.pack=function(t,o,a){let s;a=e.defaultValue(a,0);const r=t._positions;let l=r.length;for(o[a++]=l,s=0;s<l;++s,a+=n.Cartesian3.packedLength)n.Cartesian3.pack(r[s],o,a);const m=t._minimumHeights;if(l=e.defined(m)?m.length:0,o[a++]=l,e.defined(m))for(s=0;s<l;++s)o[a++]=m[s];const d=t._maximumHeights;if(l=e.defined(d)?d.length:0,o[a++]=l,e.defined(d))for(s=0;s<l;++s)o[a++]=d[s];return i.Ellipsoid.pack(t._ellipsoid,o,a),o[a+=i.Ellipsoid.packedLength]=t._granularity,o};const k=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),w={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:k,granularity:void 0};return A.unpack=function(t,o,a){let s;o=e.defaultValue(o,0);let r=t[o++];const l=new Array(r);for(s=0;s<r;++s,o+=n.Cartesian3.packedLength)l[s]=n.Cartesian3.unpack(t,o);let m,d;if(r=t[o++],r>0)for(m=new Array(r),s=0;s<r;++s)m[s]=t[o++];if(r=t[o++],r>0)for(d=new Array(r),s=0;s<r;++s)d[s]=t[o++];const u=i.Ellipsoid.unpack(t,o,k),c=t[o+=i.Ellipsoid.packedLength];return e.defined(a)?(a._positions=l,a._minimumHeights=m,a._maximumHeights=d,a._ellipsoid=i.Ellipsoid.clone(u,a._ellipsoid),a._granularity=c,a):(w.positions=l,w.minimumHeights=m,w.maximumHeights=d,w.granularity=c,new A(w))},A.fromConstantHeights=function(i){const t=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions;let n,o;const a=i.minimumHeight,s=i.maximumHeight,r=e.defined(a),l=e.defined(s);if(r||l){const e=t.length;n=r?new Array(e):void 0,o=l?new Array(e):void 0;for(let i=0;i<e;++i)r&&(n[i]=a),l&&(o[i]=s)}return new A({positions:t,maximumHeights:o,minimumHeights:n,ellipsoid:i.ellipsoid})},A.createGeometry=function(i){const a=i._positions,u=i._minimumHeights,c=i._maximumHeights,p=i._granularity,f=i._ellipsoid,h=d.WallGeometryLibrary.computePositions(f,a,c,u,p,!1);if(!e.defined(h))return;const g=h.bottomPositions,y=h.topPositions;let _=y.length,E=2*_;const b=new Float64Array(E);let A,k=0;for(_/=3,A=0;A<_;++A){const e=3*A,i=n.Cartesian3.fromArray(y,e,H),t=n.Cartesian3.fromArray(g,e,C);b[k++]=t.x,b[k++]=t.y,b[k++]=t.z,b[k++]=i.x,b[k++]=i.y,b[k++]=i.z}const w=new r.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:b})}),x=E/3;E=2*x-4+x;const G=l.IndexDatatype.createTypedArray(x,E);let L=0;for(A=0;A<x-2;A+=2){const e=A,i=A+2,t=n.Cartesian3.fromArray(b,3*e,H),o=n.Cartesian3.fromArray(b,3*i,C);if(n.Cartesian3.equalsEpsilon(t,o,m.CesiumMath.EPSILON10))continue;const a=A+1,s=A+3;G[L++]=a,G[L++]=e,G[L++]=a,G[L++]=s,G[L++]=e,G[L++]=i}return G[L++]=x-2,G[L++]=x-1,new s.Geometry({attributes:w,indices:G,primitiveType:s.PrimitiveType.LINES,boundingSphere:new t.BoundingSphere.fromVertices(b)})},function(t,n){return e.defined(n)&&(t=A.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),A.createGeometry(t)}}));
