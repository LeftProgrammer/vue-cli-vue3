define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-51e2663f","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./defaultValue-81eec7ed","./RuntimeError-8952249c","./EllipseGeometryLibrary-1eee59e4","./Ellipsoid-119327cb","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304"],(function(e,t,i,r,n,a,o,s,l,u,c,d,p){"use strict";const f=new r.Cartesian3;let m=new r.Cartesian3;const h=new i.BoundingSphere,y=new i.BoundingSphere;function b(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).center,i=a.defaultValue(e.ellipsoid,l.Ellipsoid.WGS84),n=e.semiMajorAxis,o=e.semiMinorAxis,s=a.defaultValue(e.granularity,p.CesiumMath.RADIANS_PER_DEGREE),u=a.defaultValue(e.height,0),c=a.defaultValue(e.extrudedHeight,u);this._center=r.Cartesian3.clone(t),this._semiMajorAxis=n,this._semiMinorAxis=o,this._ellipsoid=l.Ellipsoid.clone(i),this._rotation=a.defaultValue(e.rotation,0),this._height=Math.max(c,u),this._granularity=s,this._extrudedHeight=Math.min(c,u),this._numberOfVerticalLines=Math.max(a.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}b.packedLength=r.Cartesian3.packedLength+l.Ellipsoid.packedLength+8,b.pack=function(e,t,i){return i=a.defaultValue(i,0),r.Cartesian3.pack(e._center,t,i),i+=r.Cartesian3.packedLength,l.Ellipsoid.pack(e._ellipsoid,t,i),i+=l.Ellipsoid.packedLength,t[i++]=e._semiMajorAxis,t[i++]=e._semiMinorAxis,t[i++]=e._rotation,t[i++]=e._height,t[i++]=e._granularity,t[i++]=e._extrudedHeight,t[i++]=e._numberOfVerticalLines,t[i]=a.defaultValue(e._offsetAttribute,-1),t};const A=new r.Cartesian3,_=new l.Ellipsoid,g={center:A,ellipsoid:_,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};b.unpack=function(e,t,i){t=a.defaultValue(t,0);const n=r.Cartesian3.unpack(e,t,A);t+=r.Cartesian3.packedLength;const o=l.Ellipsoid.unpack(e,t,_);t+=l.Ellipsoid.packedLength;const s=e[t++],u=e[t++],c=e[t++],d=e[t++],p=e[t++],f=e[t++],m=e[t++],h=e[t];return a.defined(i)?(i._center=r.Cartesian3.clone(n,i._center),i._ellipsoid=l.Ellipsoid.clone(o,i._ellipsoid),i._semiMajorAxis=s,i._semiMinorAxis=u,i._rotation=c,i._height=d,i._granularity=p,i._extrudedHeight=f,i._numberOfVerticalLines=m,i._offsetAttribute=-1===h?void 0:h,i):(g.height=d,g.extrudedHeight=f,g.granularity=p,g.rotation=c,g.semiMajorAxis=s,g.semiMinorAxis=u,g.numberOfVerticalLines=m,g.offsetAttribute=-1===h?void 0:h,new b(g))},b.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const o=e._height,l=e._extrudedHeight,b=!p.CesiumMath.equalsEpsilon(o,l,0,p.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const A={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:o,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let _;if(b)A.extrudedHeight=l,A.offsetAttribute=e._offsetAttribute,_=function(e){const o=e.center,l=e.ellipsoid,m=e.semiMajorAxis;let b=r.Cartesian3.multiplyByScalar(l.geodeticSurfaceNormal(o,f),e.height,f);h.center=r.Cartesian3.add(o,b,h.center),h.radius=m,b=r.Cartesian3.multiplyByScalar(l.geodeticSurfaceNormal(o,b),e.extrudedHeight,b),y.center=r.Cartesian3.add(o,b,y.center),y.radius=m;let A=s.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions;const _=new c.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:s.EllipseGeometryLibrary.raisePositionsToHeight(A,e,!0)})});A=_.position.values;const g=i.BoundingSphere.union(h,y);let E=A.length/3;if(a.defined(e.offsetAttribute)){let i=new Uint8Array(E);if(e.offsetAttribute===t.GeometryOffsetAttribute.TOP)i=t.arrayFill(i,1,0,E/2);else{const r=e.offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;i=t.arrayFill(i,r)}_.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}let x=a.defaultValue(e.numberOfVerticalLines,16);x=p.CesiumMath.clamp(x,0,E/2);const M=d.IndexDatatype.createTypedArray(E,2*E+2*x);E/=2;let C,G,L=0;for(C=0;C<E;++C)M[L++]=C,M[L++]=(C+1)%E,M[L++]=C+E,M[L++]=(C+1)%E+E;if(x>0){const e=Math.min(x,E);G=Math.round(E/e);const t=Math.min(G*x,E);for(C=0;C<t;C+=G)M[L++]=C,M[L++]=C+E}return{boundingSphere:g,attributes:_,indices:M}}(A);else if(_=function(e){const t=e.center;m=r.Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t,m),e.height,m),m=r.Cartesian3.add(t,m,m);const a=new i.BoundingSphere(m,e.semiMajorAxis),o=s.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions,l=new c.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:s.EllipseGeometryLibrary.raisePositionsToHeight(o,e,!1)})}),p=o.length/3,f=d.IndexDatatype.createTypedArray(p,2*p);let h=0;for(let e=0;e<p;++e)f[h++]=e,f[h++]=(e+1)%p;return{boundingSphere:a,attributes:l,indices:f}}(A),a.defined(e._offsetAttribute)){const i=_.attributes.position.values.length,r=new Uint8Array(i/3),a=e._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;t.arrayFill(r,a),_.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new u.Geometry({attributes:_.attributes,indices:_.indices,primitiveType:u.PrimitiveType.LINES,boundingSphere:_.boundingSphere,offsetAttribute:e._offsetAttribute})},e.EllipseOutlineGeometry=b}));
