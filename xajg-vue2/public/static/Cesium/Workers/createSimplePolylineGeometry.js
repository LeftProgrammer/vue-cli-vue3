define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./ArcType-fc72c06c","./Transforms-51e2663f","./Matrix4-3b2c0630","./Color-5a9f5f10","./ComponentDatatype-c4f4738c","./RuntimeError-8952249c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./PolylinePipeline-cfd2c1cf","./Matrix2-115e2170","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271","./IntersectionTests-4511d2eb","./Plane-f0451b7c"],(function(e,o,t,l,r,n,i,a,s,c,p,d,f,y,u,h,C,m,T,g,b){"use strict";function _(e,o,t,l,r,i,a){const s=f.PolylinePipeline.numberOfPoints(e,o,r);let c;const p=t.red,d=t.green,y=t.blue,u=t.alpha,h=l.red,C=l.green,m=l.blue,T=l.alpha;if(n.Color.equals(t,l)){for(c=0;c<s;c++)i[a++]=n.Color.floatToByte(p),i[a++]=n.Color.floatToByte(d),i[a++]=n.Color.floatToByte(y),i[a++]=n.Color.floatToByte(u);return a}const g=(h-p)/s,b=(C-d)/s,_=(m-y)/s,P=(T-u)/s;let B=a;for(c=0;c<s;c++)i[B++]=n.Color.floatToByte(p+c*g),i[B++]=n.Color.floatToByte(d+c*b),i[B++]=n.Color.floatToByte(y+c*_),i[B++]=n.Color.floatToByte(u+c*P);return B}function P(l){const i=(l=e.defaultValue(l,e.defaultValue.EMPTY_OBJECT)).positions,a=l.colors,s=e.defaultValue(l.colorsPerVertex,!1);this._positions=i,this._colors=a,this._colorsPerVertex=s,this._arcType=e.defaultValue(l.arcType,t.ArcType.GEODESIC),this._granularity=e.defaultValue(l.granularity,d.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(l.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let c=1+i.length*r.Cartesian3.packedLength;c+=e.defined(a)?1+a.length*n.Color.packedLength:1,this.packedLength=c+o.Ellipsoid.packedLength+3}P.pack=function(t,l,i){let a;i=e.defaultValue(i,0);const s=t._positions;let c=s.length;for(l[i++]=c,a=0;a<c;++a,i+=r.Cartesian3.packedLength)r.Cartesian3.pack(s[a],l,i);const p=t._colors;for(c=e.defined(p)?p.length:0,l[i++]=c,a=0;a<c;++a,i+=n.Color.packedLength)n.Color.pack(p[a],l,i);return o.Ellipsoid.pack(t._ellipsoid,l,i),i+=o.Ellipsoid.packedLength,l[i++]=t._colorsPerVertex?1:0,l[i++]=t._arcType,l[i]=t._granularity,l},P.unpack=function(t,l,i){let a;l=e.defaultValue(l,0);let s=t[l++];const c=new Array(s);for(a=0;a<s;++a,l+=r.Cartesian3.packedLength)c[a]=r.Cartesian3.unpack(t,l);s=t[l++];const p=s>0?new Array(s):void 0;for(a=0;a<s;++a,l+=n.Color.packedLength)p[a]=n.Color.unpack(t,l);const d=o.Ellipsoid.unpack(t,l);l+=o.Ellipsoid.packedLength;const f=1===t[l++],y=t[l++],u=t[l];return e.defined(i)?(i._positions=c,i._colors=p,i._ellipsoid=d,i._colorsPerVertex=f,i._arcType=y,i._granularity=u,i):new P({positions:c,colors:p,ellipsoid:d,colorsPerVertex:f,arcType:y,granularity:u})};const B=new Array(2),E=new Array(2),A={positions:B,height:E,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return P.createGeometry=function(o){const a=o._positions,y=o._colors,u=o._colorsPerVertex,h=o._arcType,C=o._granularity,m=o._ellipsoid,T=d.CesiumMath.chordLength(C,m.maximumRadius),g=e.defined(y)&&!u;let b;const P=a.length;let k,G,D,L,w=0;if(h===t.ArcType.GEODESIC||h===t.ArcType.RHUMB){let o,l,r;h===t.ArcType.GEODESIC?(o=d.CesiumMath.chordLength(C,m.maximumRadius),l=f.PolylinePipeline.numberOfPoints,r=f.PolylinePipeline.generateArc):(o=C,l=f.PolylinePipeline.numberOfPointsRhumbLine,r=f.PolylinePipeline.generateRhumbArc);const i=f.PolylinePipeline.extractHeights(a,m),s=A;if(h===t.ArcType.GEODESIC?s.minDistance=T:s.granularity=C,s.ellipsoid=m,g){let t=0;for(b=0;b<P-1;b++)t+=l(a[b],a[b+1],o)+1;k=new Float64Array(3*t),D=new Uint8Array(4*t),s.positions=B,s.height=E;let c=0;for(b=0;b<P-1;++b){B[0]=a[b],B[1]=a[b+1],E[0]=i[b],E[1]=i[b+1];const o=r(s);if(e.defined(y)){const e=o.length/3;L=y[b];for(let o=0;o<e;++o)D[c++]=n.Color.floatToByte(L.red),D[c++]=n.Color.floatToByte(L.green),D[c++]=n.Color.floatToByte(L.blue),D[c++]=n.Color.floatToByte(L.alpha)}k.set(o,w),w+=o.length}}else if(s.positions=a,s.height=i,k=new Float64Array(r(s)),e.defined(y)){for(D=new Uint8Array(k.length/3*4),b=0;b<P-1;++b){w=_(a[b],a[b+1],y[b],y[b+1],T,D,w)}const e=y[P-1];D[w++]=n.Color.floatToByte(e.red),D[w++]=n.Color.floatToByte(e.green),D[w++]=n.Color.floatToByte(e.blue),D[w++]=n.Color.floatToByte(e.alpha)}}else{G=g?2*P-2:P,k=new Float64Array(3*G),D=e.defined(y)?new Uint8Array(4*G):void 0;let o=0,t=0;for(b=0;b<P;++b){const l=a[b];if(g&&b>0&&(r.Cartesian3.pack(l,k,o),o+=3,L=y[b-1],D[t++]=n.Color.floatToByte(L.red),D[t++]=n.Color.floatToByte(L.green),D[t++]=n.Color.floatToByte(L.blue),D[t++]=n.Color.floatToByte(L.alpha)),g&&b===P-1)break;r.Cartesian3.pack(l,k,o),o+=3,e.defined(y)&&(L=y[b],D[t++]=n.Color.floatToByte(L.red),D[t++]=n.Color.floatToByte(L.green),D[t++]=n.Color.floatToByte(L.blue),D[t++]=n.Color.floatToByte(L.alpha))}}const V=new c.GeometryAttributes;V.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k}),e.defined(y)&&(V.color=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:D,normalize:!0})),G=k.length/3;const x=2*(G-1),S=p.IndexDatatype.createTypedArray(G,x);let I=0;for(b=0;b<G-1;++b)S[I++]=b,S[I++]=b+1;return new s.Geometry({attributes:V,indices:S,primitiveType:s.PrimitiveType.LINES,boundingSphere:l.BoundingSphere.fromPoints(a)})},function(t,l){return e.defined(l)&&(t=P.unpack(t,l)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),P.createGeometry(t)}}));
