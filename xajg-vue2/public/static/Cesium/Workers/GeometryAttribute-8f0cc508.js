define(["exports","./Matrix2-115e2170","./Matrix4-3b2c0630","./Ellipsoid-119327cb","./RuntimeError-8952249c","./defaultValue-81eec7ed","./WebGLConstants-508b9636","./Transforms-51e2663f"],(function(t,e,n,a,i,r,o,s){"use strict";var u=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const I={POINTS:o.WebGLConstants.POINTS,LINES:o.WebGLConstants.LINES,LINE_LOOP:o.WebGLConstants.LINE_LOOP,LINE_STRIP:o.WebGLConstants.LINE_STRIP,TRIANGLES:o.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:o.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:o.WebGLConstants.TRIANGLE_FAN,validate:function(t){return t===I.POINTS||t===I.LINES||t===I.LINE_LOOP||t===I.LINE_STRIP||t===I.TRIANGLES||t===I.TRIANGLE_STRIP||t===I.TRIANGLE_FAN}};var N=Object.freeze(I);function c(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=r.defaultValue(t.primitiveType,N.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=r.defaultValue(t.geometryType,u.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute,this.MaxPoint=t.MaxPoint,this.MinPoint=t.MinPoint}c.computeNumberOfVertices=function(t){let e=-1;for(const n in t.attributes)if(t.attributes.hasOwnProperty(n)&&r.defined(t.attributes[n])&&r.defined(t.attributes[n].values)){const a=t.attributes[n];e=a.values.length/a.componentsPerAttribute}return e};const l=new a.Cartographic,T=new n.Cartesian3,p=new n.Matrix4,m=[new a.Cartographic,new a.Cartographic,new a.Cartographic],E=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],b=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],f=new n.Cartesian3,y=new s.Quaternion,h=new n.Matrix4,L=new e.Matrix2;c._textureCoordinateRotationPoints=function(t,i,r,o){let u;const I=e.Rectangle.center(o,l),N=a.Cartographic.toCartesian(I,r,T),c=s.Transforms.eastNorthUpToFixedFrame(N,r,p),C=n.Matrix4.inverse(c,p),x=E,d=m;d[0].longitude=o.west,d[0].latitude=o.south,d[1].longitude=o.west,d[1].latitude=o.north,d[2].longitude=o.east,d[2].latitude=o.south;let P=f;for(u=0;u<3;u++)a.Cartographic.toCartesian(d[u],r,P),P=n.Matrix4.multiplyByPointAsVector(C,P,P),x[u].x=P.x,x[u].y=P.y;const A=s.Quaternion.fromAxisAngle(n.Cartesian3.UNIT_Z,-i,y),S=n.Matrix3.fromQuaternion(A,h),G=t.length;let M=Number.POSITIVE_INFINITY,R=Number.POSITIVE_INFINITY,w=Number.NEGATIVE_INFINITY,O=Number.NEGATIVE_INFINITY;for(u=0;u<G;u++)P=n.Matrix4.multiplyByPointAsVector(C,t[u],P),P=n.Matrix3.multiplyByVector(S,P,P),M=Math.min(M,P.x),R=Math.min(R,P.y),w=Math.max(w,P.x),O=Math.max(O,P.y);const _=e.Matrix2.fromRotation(i,L),g=b;g[0].x=M,g[0].y=R,g[1].x=M,g[1].y=O,g[2].x=w,g[2].y=R;const V=x[0],v=x[2].x-V.x,F=x[1].y-V.y;for(u=0;u<3;u++){const t=g[u];e.Matrix2.multiplyByVector(_,t,t),t.x=(t.x-V.x)/v,t.y=(t.y-V.y)/F}const W=g[0],Y=g[1],B=g[2],z=new Array(6);return e.Cartesian2.pack(W,z),e.Cartesian2.pack(Y,z,2),e.Cartesian2.pack(B,z,4),z},t.Geometry=c,t.GeometryAttribute=function(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT),this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=r.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=u,t.PrimitiveType=N}));
