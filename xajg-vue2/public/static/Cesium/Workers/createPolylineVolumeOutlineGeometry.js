define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./arrayRemoveDuplicates-4bbe2c1f","./BoundingRectangle-3faabee8","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./PolylineVolumeGeometryLibrary-e2c85c62","./RuntimeError-8952249c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonPipeline-ef9e08dd","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-6354c9aa","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./PolylinePipeline-cfd2c1cf","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271"],(function(e,t,i,n,o,a,l,r,s,p,c,d,u,y,f,g,h,m,E,b,_,P,k,C,L){"use strict";function T(i){const n=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).polylinePositions,o=i.shapePositions;this._positions=n,this._shape=o,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(i.cornerType,s.CornerType.ROUNDED),this._granularity=e.defaultValue(i.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeOutlineGeometry";let r=1+n.length*l.Cartesian3.packedLength;r+=1+o.length*a.Cartesian2.packedLength,this.packedLength=r+t.Ellipsoid.packedLength+2}T.pack=function(i,n,o){let r;o=e.defaultValue(o,0);const s=i._positions;let p=s.length;for(n[o++]=p,r=0;r<p;++r,o+=l.Cartesian3.packedLength)l.Cartesian3.pack(s[r],n,o);const c=i._shape;for(p=c.length,n[o++]=p,r=0;r<p;++r,o+=a.Cartesian2.packedLength)a.Cartesian2.pack(c[r],n,o);return t.Ellipsoid.pack(i._ellipsoid,n,o),o+=t.Ellipsoid.packedLength,n[o++]=i._cornerType,n[o]=i._granularity,n};const D=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),G={polylinePositions:void 0,shapePositions:void 0,ellipsoid:D,height:void 0,cornerType:void 0,granularity:void 0};T.unpack=function(i,n,o){let r;n=e.defaultValue(n,0);let s=i[n++];const p=new Array(s);for(r=0;r<s;++r,n+=l.Cartesian3.packedLength)p[r]=l.Cartesian3.unpack(i,n);s=i[n++];const c=new Array(s);for(r=0;r<s;++r,n+=a.Cartesian2.packedLength)c[r]=a.Cartesian2.unpack(i,n);const d=t.Ellipsoid.unpack(i,n,D);n+=t.Ellipsoid.packedLength;const u=i[n++],y=i[n];return e.defined(o)?(o._positions=p,o._shape=c,o._ellipsoid=t.Ellipsoid.clone(d,o._ellipsoid),o._cornerType=u,o._granularity=y,o):(G.polylinePositions=p,G.shapePositions=c,G.cornerType=u,G.granularity=y,new T(G))};const v=new n.BoundingRectangle;return T.createGeometry=function(e){const t=e._positions,a=i.arrayRemoveDuplicates(t,l.Cartesian3.equalsEpsilon);let p=e._shape;if(p=s.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(p),a.length<2||p.length<3)return;f.PolygonPipeline.computeWindingOrder2D(p)===f.WindingOrder.CLOCKWISE&&p.reverse();const y=n.BoundingRectangle.fromPoints(p,v);return function(e,t){const i=new d.GeometryAttributes;i.position=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e});const n=t.length,a=i.position.values.length/3,l=e.length/3/n,s=u.IndexDatatype.createTypedArray(a,2*n*(l+1));let p,y,f=0;p=0;let g=p*n;for(y=0;y<n-1;y++)s[f++]=y+g,s[f++]=y+g+1;for(s[f++]=n-1+g,s[f++]=g,p=l-1,g=p*n,y=0;y<n-1;y++)s[f++]=y+g,s[f++]=y+g+1;for(s[f++]=n-1+g,s[f++]=g,p=0;p<l-1;p++){const e=n*p,t=e+n;for(y=0;y<n;y++)s[f++]=y+e,s[f++]=y+t}return new c.Geometry({attributes:i,indices:u.IndexDatatype.createTypedArray(a,s),boundingSphere:o.BoundingSphere.fromVertices(e),primitiveType:c.PrimitiveType.LINES})}(s.PolylineVolumeGeometryLibrary.computePositions(a,p,y,e,!1),p)},function(i,n){return e.defined(n)&&(i=T.unpack(i,n)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),T.createGeometry(i)}}));
