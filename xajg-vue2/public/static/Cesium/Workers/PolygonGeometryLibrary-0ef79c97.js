define(["exports","./ArcType-fc72c06c","./arrayRemoveDuplicates-4bbe2c1f","./Matrix2-115e2170","./Matrix4-3b2c0630","./Ellipsoid-119327cb","./ComponentDatatype-c4f4738c","./defaultValue-81eec7ed","./EllipsoidRhumbLine-6fa5d271","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./GeometryPipeline-1ba2ded0","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonPipeline-ef9e08dd","./Transforms-51e2663f"],(function(e,t,n,i,o,r,s,a,c,l,u,h,f,p,d,y){"use strict";function g(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(g.prototype,{length:{get:function(){return this._length}}}),g.prototype.enqueue=function(e){this._array.push(e),this._length++},g.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},g.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},g.prototype.contains=function(e){return-1!==this._array.indexOf(e)},g.prototype.clear=function(){this._array.length=this._offset=this._length=0},g.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};const m={computeHierarchyPackedLength:function(e){let t=0;const n=[e];for(;n.length>0;){const e=n.pop();if(!a.defined(e))continue;t+=2;const i=e.positions,r=e.holes;if(a.defined(i)&&(t+=i.length*o.Cartesian3.packedLength),a.defined(r)){const e=r.length;for(let t=0;t<e;++t)n.push(r[t])}}return t},packPolygonHierarchy:function(e,t,n){const i=[e];for(;i.length>0;){const e=i.pop();if(!a.defined(e))continue;const r=e.positions,s=e.holes;if(t[n++]=a.defined(r)?r.length:0,t[n++]=a.defined(s)?s.length:0,a.defined(r)){const e=r.length;for(let i=0;i<e;++i,n+=3)o.Cartesian3.pack(r[i],t,n)}if(a.defined(s)){const e=s.length;for(let t=0;t<e;++t)i.push(s[t])}}return n},unpackPolygonHierarchy:function(e,t){const n=e[t++],i=e[t++],r=new Array(n),s=i>0?new Array(i):void 0;for(let i=0;i<n;++i,t+=o.Cartesian3.packedLength)r[i]=o.Cartesian3.unpack(e,t);for(let n=0;n<i;++n)s[n]=m.unpackPolygonHierarchy(e,t),t=s[n].startingIndex,delete s[n].startingIndex;return{positions:r,holes:s,startingIndex:t}}},C=new o.Cartesian3;function b(e,t,n,i){return o.Cartesian3.subtract(t,e,C),o.Cartesian3.multiplyByScalar(C,n/i,C),o.Cartesian3.add(e,C,C),[C.x,C.y,C.z]}m.subdivideLineCount=function(e,t,n){const i=o.Cartesian3.distance(e,t)/n,r=Math.max(0,Math.ceil(p.CesiumMath.log2(i)));return Math.pow(2,r)};const T=new r.Cartographic,w=new r.Cartographic,x=new r.Cartographic,I=new o.Cartesian3;m.subdivideRhumbLineCount=function(e,t,n,i){const o=e.cartesianToCartographic(t,T),r=e.cartesianToCartographic(n,w),s=new c.EllipsoidRhumbLine(o,r,e).surfaceDistance/i,a=Math.max(0,Math.ceil(p.CesiumMath.log2(s)));return Math.pow(2,a)},m.subdivideLine=function(e,t,n,i){const r=m.subdivideLineCount(e,t,n),s=o.Cartesian3.distance(e,t),c=s/r;a.defined(i)||(i=[]);const l=i;l.length=3*r;let u=0;for(let n=0;n<r;n++){const i=b(e,t,n*c,s);l[u++]=i[0],l[u++]=i[1],l[u++]=i[2]}return l},m.subdivideRhumbLine=function(e,t,n,i,o){const r=e.cartesianToCartographic(t,T),s=e.cartesianToCartographic(n,w),l=new c.EllipsoidRhumbLine(r,s,e),u=l.surfaceDistance/i,h=Math.max(0,Math.ceil(p.CesiumMath.log2(u))),f=Math.pow(2,h),d=l.surfaceDistance/f;a.defined(o)||(o=[]);const y=o;y.length=3*f;let g=0;for(let t=0;t<f;t++){const n=l.interpolateUsingSurfaceDistance(t*d,x),i=e.cartographicToCartesian(n,I);y[g++]=i.x,y[g++]=i.y,y[g++]=i.z}return y};const E=new o.Cartesian3,v=new o.Cartesian3,A=new o.Cartesian3,P=new o.Cartesian3;m.scaleToGeodeticHeightExtruded=function(e,t,n,i,s){i=a.defaultValue(i,r.Ellipsoid.WGS84);const c=E;let l=v;const u=A;let h=P;if(a.defined(e)&&a.defined(e.attributes)&&a.defined(e.attributes.position)){const r=e.attributes.position.values,a=r.length/2;for(let e=0;e<a;e+=3)o.Cartesian3.fromArray(r,e,u),i.geodeticSurfaceNormal(u,c),h=i.scaleToGeodeticSurface(u,h),l=o.Cartesian3.multiplyByScalar(c,n,l),l=o.Cartesian3.add(h,l,l),r[e+a]=l.x,r[e+1+a]=l.y,r[e+2+a]=l.z,s&&(h=o.Cartesian3.clone(u,h)),l=o.Cartesian3.multiplyByScalar(c,t,l),l=o.Cartesian3.add(h,l,l),r[e]=l.x,r[e+1]=l.y,r[e+2]=l.z}return e},m.polygonOutlinesFromHierarchy=function(e,t,i){const r=[],s=new g;let c,l,u;for(s.enqueue(e);0!==s.length;){const e=s.dequeue();let h=e.positions;if(t)for(u=h.length,c=0;c<u;c++)i.scaleToGeodeticSurface(h[c],h[c]);if(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0),h.length<3)continue;const f=e.holes?e.holes.length:0;for(c=0;c<f;c++){const h=e.holes[c];let f=h.positions;if(t)for(u=f.length,l=0;l<u;++l)i.scaleToGeodeticSurface(f[l],f[l]);if(f=n.arrayRemoveDuplicates(f,o.Cartesian3.equalsEpsilon,!0),f.length<3)continue;r.push(f);let p=0;for(a.defined(h.holes)&&(p=h.holes.length),l=0;l<p;l++)s.enqueue(h.holes[l])}r.push(h)}return r},m.polygonsFromHierarchy=function(e,t,i,r){const s=[],c=[],l=new g;for(l.enqueue(e);0!==l.length;){const e=l.dequeue();let u=e.positions;const h=e.holes;let f,p;if(i)for(p=u.length,f=0;f<p;f++)r.scaleToGeodeticSurface(u[f],u[f]);if(u=n.arrayRemoveDuplicates(u,o.Cartesian3.equalsEpsilon,!0),u.length<3)continue;let y=t(u);if(!a.defined(y))continue;const g=[];let m=d.PolygonPipeline.computeWindingOrder2D(y);m===d.WindingOrder.CLOCKWISE&&(y.reverse(),u=u.slice().reverse());let C=u.slice();const b=a.defined(h)?h.length:0,T=[];let w;for(f=0;f<b;f++){const e=h[f];let s=e.positions;if(i)for(p=s.length,w=0;w<p;++w)r.scaleToGeodeticSurface(s[w],s[w]);if(s=n.arrayRemoveDuplicates(s,o.Cartesian3.equalsEpsilon,!0),s.length<3)continue;const c=t(s);if(!a.defined(c))continue;m=d.PolygonPipeline.computeWindingOrder2D(c),m===d.WindingOrder.CLOCKWISE&&(c.reverse(),s=s.slice().reverse()),T.push(s),g.push(C.length),C=C.concat(s),y=y.concat(c);let u=0;for(a.defined(e.holes)&&(u=e.holes.length),w=0;w<u;w++)l.enqueue(e.holes[w])}s.push({outerRing:u,holes:T}),c.push({positions:C,positions2D:y,holes:g})}return{hierarchy:s,polygons:c}};const _=new i.Cartesian2,M=new o.Cartesian3,G=new y.Quaternion,L=new o.Matrix3;m.computeBoundingRectangle=function(e,t,n,i,r){const s=y.Quaternion.fromAxisAngle(e,i,G),c=o.Matrix3.fromQuaternion(s,L);let l=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY;const p=n.length;for(let e=0;e<p;++e){const i=o.Cartesian3.clone(n[e],M);o.Matrix3.multiplyByVector(c,i,i);const r=t(i,_);a.defined(r)&&(l=Math.min(l,r.x),u=Math.max(u,r.x),h=Math.min(h,r.y),f=Math.max(f,r.y))}return r.x=l,r.y=h,r.width=u-l,r.height=f-h,r},m.createGeometryFromPositions=function(e,n,i,o,r,a){let c=d.PolygonPipeline.triangulate(n.positions2D,n.holes);c.length<3&&(c=[0,1,2]);const u=n.positions;if(o){const e=u.length,t=new Array(3*e);let n=0;for(let i=0;i<e;i++){const e=u[i];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const i=new l.Geometry({attributes:{position:new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})},indices:c,primitiveType:l.PrimitiveType.TRIANGLES});return r.normal?h.GeometryPipeline.computeNormal(i):i}return a===t.ArcType.GEODESIC?d.PolygonPipeline.computeSubdivision(e,u,c,i):a===t.ArcType.RHUMB?d.PolygonPipeline.computeRhumbLineSubdivision(e,u,c,i):void 0};const D=[],S=new o.Cartesian3,R=new o.Cartesian3;m.computeWallGeometry=function(e,n,i,r,a){let c,h,d,y,g,C=e.length,b=0;if(r)for(h=3*C*2,c=new Array(2*h),d=0;d<C;d++)y=e[d],g=e[(d+1)%C],c[b]=c[b+h]=y.x,++b,c[b]=c[b+h]=y.y,++b,c[b]=c[b+h]=y.z,++b,c[b]=c[b+h]=g.x,++b,c[b]=c[b+h]=g.y,++b,c[b]=c[b+h]=g.z,++b;else{const o=p.CesiumMath.chordLength(i,n.maximumRadius);let r=0;if(a===t.ArcType.GEODESIC)for(d=0;d<C;d++)r+=m.subdivideLineCount(e[d],e[(d+1)%C],o);else if(a===t.ArcType.RHUMB)for(d=0;d<C;d++)r+=m.subdivideRhumbLineCount(n,e[d],e[(d+1)%C],o);for(h=3*(r+C),c=new Array(2*h),d=0;d<C;d++){let i;y=e[d],g=e[(d+1)%C],a===t.ArcType.GEODESIC?i=m.subdivideLine(y,g,o,D):a===t.ArcType.RHUMB&&(i=m.subdivideRhumbLine(n,y,g,o,D));const r=i.length;for(let e=0;e<r;++e,++b)c[b]=i[e],c[b+h]=i[e];c[b]=g.x,c[b+h]=g.x,++b,c[b]=g.y,c[b+h]=g.y,++b,c[b]=g.z,c[b+h]=g.z,++b}}C=c.length;const T=f.IndexDatatype.createTypedArray(C/3,C-6*e.length);let w=0;for(C/=6,d=0;d<C;d++){const e=d,t=e+1,n=e+C,i=n+1;y=o.Cartesian3.fromArray(c,3*e,S),g=o.Cartesian3.fromArray(c,3*t,R),o.Cartesian3.equalsEpsilon(y,g,p.CesiumMath.EPSILON10,p.CesiumMath.EPSILON10)||(T[w++]=e,T[w++]=n,T[w++]=t,T[w++]=t,T[w++]=n,T[w++]=i)}return new l.Geometry({attributes:new u.GeometryAttributes({position:new l.GeometryAttribute({componentDatatype:s.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:T,primitiveType:l.PrimitiveType.TRIANGLES})},e.PolygonGeometryLibrary=m}));
