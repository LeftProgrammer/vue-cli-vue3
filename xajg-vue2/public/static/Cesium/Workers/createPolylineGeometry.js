define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./ArcType-fc72c06c","./arrayRemoveDuplicates-4bbe2c1f","./Transforms-51e2663f","./Matrix4-3b2c0630","./Color-5a9f5f10","./ComponentDatatype-c4f4738c","./RuntimeError-8952249c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./PolylinePipeline-cfd2c1cf","./VertexFormat-a0b706b0","./Matrix2-115e2170","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271","./IntersectionTests-4511d2eb","./Plane-f0451b7c"],(function(e,t,o,r,n,a,i,l,s,c,p,d,u,y,m,f,h,C,g,b,_,A,E){"use strict";const P=[];function x(e,t,o,r,n){const a=P;let l;a.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,y=r.green,m=r.blue,f=r.alpha;if(i.Color.equals(o,r)){for(l=0;l<n;l++)a[l]=i.Color.clone(o);return a}const h=(u-s)/n,C=(y-c)/n,g=(m-p)/n,b=(f-d)/n;for(l=0;l<n;l++)a[l]=new i.Color(s+l*h,c+l*C,p+l*g,d+l*b);return a}function w(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,l=r.colors,s=e.defaultValue(r.width,1),c=e.defaultValue(r.colorsPerVertex,!1);this._positions=n,this._colors=l,this._width=s,this._colorsPerVertex=c,this._vertexFormat=m.VertexFormat.clone(e.defaultValue(r.vertexFormat,m.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,u.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let p=1+n.length*a.Cartesian3.packedLength;p+=e.defined(l)?1+l.length*i.Color.packedLength:1,this.packedLength=p+t.Ellipsoid.packedLength+m.VertexFormat.packedLength+4}w.pack=function(o,r,n){let l;n=e.defaultValue(n,0);const s=o._positions;let c=s.length;for(r[n++]=c,l=0;l<c;++l,n+=a.Cartesian3.packedLength)a.Cartesian3.pack(s[l],r,n);const p=o._colors;for(c=e.defined(p)?p.length:0,r[n++]=c,l=0;l<c;++l,n+=i.Color.packedLength)i.Color.pack(p[l],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,m.VertexFormat.pack(o._vertexFormat,r,n),n+=m.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const T=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),D=new m.VertexFormat,k={positions:void 0,colors:void 0,ellipsoid:T,vertexFormat:D,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};w.unpack=function(o,r,n){let l;r=e.defaultValue(r,0);let s=o[r++];const c=new Array(s);for(l=0;l<s;++l,r+=a.Cartesian3.packedLength)c[l]=a.Cartesian3.unpack(o,r);s=o[r++];const p=s>0?new Array(s):void 0;for(l=0;l<s;++l,r+=i.Color.packedLength)p[l]=i.Color.unpack(o,r);const d=t.Ellipsoid.unpack(o,r,T);r+=t.Ellipsoid.packedLength;const u=m.VertexFormat.unpack(o,r,D);r+=m.VertexFormat.packedLength;const y=o[r++],f=1===o[r++],h=o[r++],C=o[r];return e.defined(n)?(n._positions=c,n._colors=p,n._ellipsoid=t.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=m.VertexFormat.clone(u,n._vertexFormat),n._width=y,n._colorsPerVertex=f,n._arcType=h,n._granularity=C,n):(k.positions=c,k.colors=p,k.width=y,k.colorsPerVertex=f,k.arcType=h,k.granularity=C,new w(k))};const V=new a.Cartesian3,v=new a.Cartesian3,L=new a.Cartesian3,F=new a.Cartesian3;return w.createGeometry=function(t){const s=t._width,m=t._vertexFormat;let f=t._colors;const h=t._colorsPerVertex,C=t._arcType,g=t._granularity,b=t._ellipsoid;let _,A,E;const w=[];let T=r.arrayRemoveDuplicates(t._positions,a.Cartesian3.equalsEpsilon,!1,w);if(e.defined(f)&&w.length>0){let e=0,t=w[0];f=f.filter((function(o,r){let n=!1;return n=h?r===t||0===r&&1===t:r+1===t,!n||(e++,t=w[e],!1)}))}let D=T.length;if(D<2||s<=0)return;if(C===o.ArcType.GEODESIC||C===o.ArcType.RHUMB){let t,r;C===o.ArcType.GEODESIC?(t=u.CesiumMath.chordLength(g,b.maximumRadius),r=y.PolylinePipeline.numberOfPoints):(t=g,r=y.PolylinePipeline.numberOfPointsRhumbLine);const n=y.PolylinePipeline.extractHeights(T,b);if(e.defined(f)){let e=1;for(_=0;_<D-1;++_)e+=r(T[_],T[_+1],t);const o=new Array(e);let n=0;for(_=0;_<D-1;++_){const a=T[_],l=T[_+1],s=f[_],c=r(a,l,t);if(h&&_<e){const e=x(0,0,s,f[_+1],c),t=e.length;for(A=0;A<t;++A)o[n++]=e[A]}else for(A=0;A<c;++A)o[n++]=i.Color.clone(s)}o[n]=i.Color.clone(f[f.length-1]),f=o,P.length=0}T=C===o.ArcType.GEODESIC?y.PolylinePipeline.generateCartesianArc({positions:T,minDistance:t,ellipsoid:b,height:n}):y.PolylinePipeline.generateCartesianRhumbArc({positions:T,granularity:t,ellipsoid:b,height:n})}D=T.length;const k=4*D-4,G=new Float64Array(3*k),O=new Float64Array(3*k),R=new Float64Array(3*k),I=new Float32Array(2*k),S=m.st?new Float32Array(2*k):void 0,B=e.defined(f)?new Uint8Array(4*k):void 0;let M,U=0,N=0,H=0,W=0;for(A=0;A<D;++A){let t,o;0===A?(M=V,a.Cartesian3.subtract(T[0],T[1],M),a.Cartesian3.add(T[0],M,M)):M=T[A-1],a.Cartesian3.clone(M,L),a.Cartesian3.clone(T[A],v),A===D-1?(M=V,a.Cartesian3.subtract(T[D-1],T[D-2],M),a.Cartesian3.add(T[D-1],M,M)):M=T[A+1],a.Cartesian3.clone(M,F),e.defined(B)&&(t=0===A||h?f[A]:f[A-1],A!==D-1&&(o=f[A]));const r=A===D-1?2:4;for(E=0===A?2:0;E<r;++E){a.Cartesian3.pack(v,G,U),a.Cartesian3.pack(L,O,U),a.Cartesian3.pack(F,R,U),U+=3;const r=E-2<0?-1:1;if(I[N++]=E%2*2-1,I[N++]=r*s,m.st&&(S[H++]=A/(D-1),S[H++]=Math.max(I[N-2],0)),e.defined(B)){const e=E<2?t:o;B[W++]=i.Color.floatToByte(e.red),B[W++]=i.Color.floatToByte(e.green),B[W++]=i.Color.floatToByte(e.blue),B[W++]=i.Color.floatToByte(e.alpha)}}}const Y=new p.GeometryAttributes;Y.position=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),Y.prevPosition=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),Y.nextPosition=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:R}),Y.expandAndWidth=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I}),m.st&&(Y.st=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S})),e.defined(B)&&(Y.color=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:B,normalize:!0}));const q=d.IndexDatatype.createTypedArray(k,6*D-6);let j=0,z=0;const J=D-1;for(A=0;A<J;++A)q[z++]=j,q[z++]=j+2,q[z++]=j+1,q[z++]=j+1,q[z++]=j+2,q[z++]=j+3,j+=4;return new c.Geometry({attributes:Y,indices:q,primitiveType:c.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(T),geometryType:c.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=w.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),w.createGeometry(o)}}));
