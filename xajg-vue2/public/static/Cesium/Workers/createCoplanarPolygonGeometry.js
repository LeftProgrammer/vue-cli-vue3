define(["./arrayRemoveDuplicates-4bbe2c1f","./BoundingRectangle-3faabee8","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./CoplanarPolygonGeometryLibrary-c42b3e43","./defaultValue-81eec7ed","./Ellipsoid-119327cb","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./GeometryInstance-57a5edd8","./GeometryPipeline-1ba2ded0","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonGeometryLibrary-0ef79c97","./PolygonPipeline-ef9e08dd","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./OrientedBoundingBox-8f892e7f","./EllipsoidTangentPlane-6354c9aa","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./AttributeCompression-cf8328fe","./EncodedCartesian3-e203d8be","./ArcType-fc72c06c","./EllipsoidRhumbLine-6fa5d271"],(function(e,t,n,o,a,r,i,s,l,c,p,y,u,m,d,g,b,f,h,x,C,P,A,w,F,G,L,E,v,T,D){"use strict";const _=new a.Cartesian3,V=new t.BoundingRectangle,k=new o.Cartesian2,R=new o.Cartesian2,M=new a.Cartesian3,I=new a.Cartesian3,B=new a.Cartesian3,H=new a.Cartesian3,O=new a.Cartesian3,z=new a.Cartesian3,S=new n.Quaternion,N=new a.Matrix3,Q=new a.Matrix3,j=new a.Cartesian3;function U(e,t,r,s,l,c,u,m){const b=e.positions;let h=f.PolygonPipeline.triangulate(e.positions2D,e.holes);h.length<3&&(h=[0,1,2]);const x=d.IndexDatatype.createTypedArray(b.length,h.length);x.set(h);let C=N;if(0!==s){let e=n.Quaternion.fromAxisAngle(c,s,S);if(C=a.Matrix3.fromQuaternion(e,C),t.tangent||t.bitangent){e=n.Quaternion.fromAxisAngle(c,-s,S);const o=a.Matrix3.fromQuaternion(e,Q);u=a.Cartesian3.normalize(a.Matrix3.multiplyByVector(o,u,u),u),t.bitangent&&(m=a.Cartesian3.normalize(a.Cartesian3.cross(c,u,m),m))}}else C=a.Matrix3.clone(a.Matrix3.IDENTITY,C);const P=R;t.st&&(P.x=r.x,P.y=r.y);const A=b.length,w=3*A,F=new Float64Array(w),G=t.normal?new Float32Array(w):void 0,L=t.tangent?new Float32Array(w):void 0,E=t.bitangent?new Float32Array(w):void 0,v=t.st?new Float32Array(2*A):void 0;let T=0,D=0,V=0,M=0,I=0;for(let e=0;e<A;e++){const n=b[e];if(F[T++]=n.x,F[T++]=n.y,F[T++]=n.z,t.st){const e=l(a.Matrix3.multiplyByVector(C,n,_),k);o.Cartesian2.subtract(e,P,e);const t=g.CesiumMath.clamp(e.x/r.width,0,1),i=g.CesiumMath.clamp(e.y/r.height,0,1);v[I++]=t,v[I++]=i}t.normal&&(G[D++]=c.x,G[D++]=c.y,G[D++]=c.z),t.tangent&&(L[M++]=u.x,L[M++]=u.y,L[M++]=u.z),t.bitangent&&(E[V++]=m.x,E[V++]=m.y,E[V++]=m.z)}const B=new y.GeometryAttributes;return t.position&&(B.position=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F})),t.normal&&(B.normal=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),t.tangent&&(B.tangent=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),t.bitangent&&(B.bitangent=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E})),t.st&&(B.st=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:v})),new p.Geometry({attributes:B,indices:x,primitiveType:p.PrimitiveType.TRIANGLES})}function Y(e){const t=(e=l.defaultValue(e,l.defaultValue.EMPTY_OBJECT)).polygonHierarchy,n=l.defaultValue(e.vertexFormat,h.VertexFormat.DEFAULT);this._vertexFormat=h.VertexFormat.clone(n),this._polygonHierarchy=t,this._stRotation=l.defaultValue(e.stRotation,0),this._ellipsoid=c.Ellipsoid.clone(l.defaultValue(e.ellipsoid,c.Ellipsoid.WGS84)),this._workerName="createCoplanarPolygonGeometry",this.packedLength=b.PolygonGeometryLibrary.computeHierarchyPackedLength(t)+h.VertexFormat.packedLength+c.Ellipsoid.packedLength+2}Y.fromPositions=function(e){return new Y({polygonHierarchy:{positions:(e=l.defaultValue(e,l.defaultValue.EMPTY_OBJECT)).positions},vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid})},Y.pack=function(e,t,n){return n=l.defaultValue(n,0),n=b.PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,n),c.Ellipsoid.pack(e._ellipsoid,t,n),n+=c.Ellipsoid.packedLength,h.VertexFormat.pack(e._vertexFormat,t,n),n+=h.VertexFormat.packedLength,t[n++]=e._stRotation,t[n]=e.packedLength,t};const q=c.Ellipsoid.clone(c.Ellipsoid.UNIT_SPHERE),J=new h.VertexFormat,W={polygonHierarchy:{}};return Y.unpack=function(e,t,n){t=l.defaultValue(t,0);const o=b.PolygonGeometryLibrary.unpackPolygonHierarchy(e,t);t=o.startingIndex,delete o.startingIndex;const a=c.Ellipsoid.unpack(e,t,q);t+=c.Ellipsoid.packedLength;const r=h.VertexFormat.unpack(e,t,J);t+=h.VertexFormat.packedLength;const i=e[t++],s=e[t];return l.defined(n)||(n=new Y(W)),n._polygonHierarchy=o,n._ellipsoid=c.Ellipsoid.clone(a,n._ellipsoid),n._vertexFormat=h.VertexFormat.clone(r,n._vertexFormat),n._stRotation=i,n.packedLength=s,n},Y.createGeometry=function(t){const o=t._vertexFormat,r=t._polygonHierarchy,i=t._stRotation;let l=r.positions;if(l=e.arrayRemoveDuplicates(l,a.Cartesian3.equalsEpsilon,!0),l.length<3)return;let c=M,y=I,f=B,h=O;const x=z;if(!s.CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(l,H,h,x))return;if(c=a.Cartesian3.cross(h,x,c),c=a.Cartesian3.normalize(c,c),!a.Cartesian3.equalsEpsilon(H,a.Cartesian3.ZERO,g.CesiumMath.EPSILON6)){const e=t._ellipsoid.geodeticSurfaceNormal(H,j);a.Cartesian3.dot(c,e)<0&&(c=a.Cartesian3.negate(c,c),h=a.Cartesian3.negate(h,h))}const C=s.CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(H,h,x),P=s.CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(H,h,x);o.tangent&&(y=a.Cartesian3.clone(h,y)),o.bitangent&&(f=a.Cartesian3.clone(x,f));const A=b.PolygonGeometryLibrary.polygonsFromHierarchy(r,C,!1),w=A.hierarchy,F=A.polygons;if(0===w.length)return;l=w[0].outerRing;const G=n.BoundingSphere.fromPoints(l),L=b.PolygonGeometryLibrary.computeBoundingRectangle(c,P,l,i,V),E=[];for(let e=0;e<F.length;e++){const t=new u.GeometryInstance({geometry:U(F[e],o,L,i,P,c,y,f)});E.push(t)}const v=m.GeometryPipeline.combineInstances(E)[0];v.attributes.position.values=new Float64Array(v.attributes.position.values),v.indices=d.IndexDatatype.createTypedArray(v.attributes.position.values.length/3,v.indices);const T=v.attributes;return o.position||delete T.position,new p.Geometry({attributes:T,indices:v.indices,primitiveType:v.primitiveType,boundingSphere:G})},function(e,t){return l.defined(t)&&(e=Y.unpack(e,t)),Y.createGeometry(e)}}));
