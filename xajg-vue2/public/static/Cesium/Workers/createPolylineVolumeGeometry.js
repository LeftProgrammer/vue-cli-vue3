define(["./defaultValue-81eec7ed","./Ellipsoid-119327cb","./arrayRemoveDuplicates-4bbe2c1f","./BoundingRectangle-3faabee8","./Transforms-51e2663f","./Matrix2-115e2170","./Matrix4-3b2c0630","./ComponentDatatype-c4f4738c","./PolylineVolumeGeometryLibrary-e2c85c62","./RuntimeError-8952249c","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./GeometryPipeline-1ba2ded0","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonPipeline-ef9e08dd","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-6354c9aa","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./PolylinePipeline-cfd2c1cf","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271","./AttributeCompression-cf8328fe","./EncodedCartesian3-e203d8be"],(function(e,t,n,o,i,r,a,l,s,d,c,p,m,u,g,y,h,f,x,b,P,_,E,L,T,F,G,v,k){"use strict";const w={};function C(t,n){e.defined(w[t])||(w[t]=!0)}function V(t,n,o,r,s,d,g){const h=new p.GeometryAttributes;r.position&&(h.position=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t}));const f=n.length,x=t.length/3;let b=(x-2*f)/(2*f);const P=y.PolygonPipeline.triangulate(n),_=(b-1)*f*6+2*P.length,E=u.IndexDatatype.createTypedArray(x,_);let L,T,F,G,v,k;const w=2*f;let V=0;for(L=0;L<b-1;L++){for(T=0;T<f-1;T++)F=2*T+L*f*2,k=F+w,G=F+1,v=G+w,E[V++]=G,E[V++]=F,E[V++]=v,E[V++]=v,E[V++]=F,E[V++]=k;F=2*f-2+L*f*2,G=F+1,v=G+w,k=F+w,E[V++]=G,E[V++]=F,E[V++]=v,E[V++]=v,E[V++]=F,E[V++]=k}if(r.st||r.tangent||r.bitangent){const e=new Float32Array(2*x),t=1/(b-1),i=1/o.height,r=o.height/2;let a,s,d=0;for(L=0;L<b;L++){for(a=L*t,s=i*(n[0].y+r),e[d++]=a,e[d++]=s,T=1;T<f;T++)s=i*(n[T].y+r),e[d++]=a,e[d++]=s,e[d++]=a,e[d++]=s;s=i*(n[0].y+r),e[d++]=a,e[d++]=s}for(T=0;T<f;T++)a=0,s=i*(n[T].y+r),e[d++]=a,e[d++]=s;for(T=0;T<f;T++)a=(b-1)*t,s=i*(n[T].y+r),e[d++]=a,e[d++]=s;h.st=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const A=x-2*f;for(L=0;L<P.length;L+=3){const e=P[L]+A,t=P[L+1]+A,n=P[L+2]+A;E[V++]=e,E[V++]=t,E[V++]=n,E[V++]=n+f,E[V++]=t+f,E[V++]=e+f}const M=function(t,n,o){const i=[],r=new a.Matrix4;e.defined(n)&&!n.equals(new a.Matrix4)&&a.Matrix4.inverse(n,r);for(let e=0;e<t.length/3;e++){const n=new a.Cartesian3(t[3*e],t[3*e+1],t[3*e+2]);1!==o&&a.Matrix4.multiplyByPoint(r,n,n),i.push(n.x,n.y,n.z)}const l=new a.Cartesian3(-1/0,-1/0,-1/0),s=new a.Cartesian3(1/0,1/0,1/0);for(let e=0;e<i.length/3;e++){const t=new a.Cartesian3(i[3*e],i[3*e+1],i[3*e+2]);l.x=Math.max(l.x,t.x),l.y=Math.max(l.y,t.y),l.z=Math.max(l.z,t.z),s.x=Math.min(s.x,t.x),s.y=Math.min(s.y,t.y),s.z=Math.min(s.z,t.z)}return[l,s]}(t,s,g);let R=new c.Geometry({attributes:h,indices:E,boundingSphere:i.BoundingSphere.fromVertices(t),MaxPoint:M[0],MinPoint:M[1],primitiveType:c.PrimitiveType.TRIANGLES});if(r.normal&&(R=m.GeometryPipeline.computeNormal(R,1===g?s:void 0)),r.tangent||r.bitangent){try{R=m.GeometryPipeline.computeTangentAndBitangent(R)}catch(e){C("polyline-volume-tangent-bitangent")}r.tangent||(R.attributes.tangent=void 0),r.bitangent||(R.attributes.bitangent=void 0),r.st||(R.attributes.st=void 0)}return R}function A(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,i=n.shapePositions;let l;this._positions=o,this._shape=i,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,s.CornerType.ROUNDED),this._vertexFormat=h.VertexFormat.clone(e.defaultValue(n.vertexFormat,h.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,g.CesiumMath.RADIANS_PER_DEGREE),e.defined(n.id)&&(l=n.id._polylineVolume.RootTransform,this._rootTransform=l),n.rootTransform&&(this._rootTransform=n.rootTransform),e.defined(n.isFromGLP)&&(this._isFromGLP=n.isFromGLP),this._workerName="createPolylineVolumeGeometry";let d=1+o.length*a.Cartesian3.packedLength;d+=1+i.length*r.Cartesian2.packedLength,e.defined(l)&&(d+=1+l.length),e.defined(n.rootTransform)&&(d+=1+n.rootTransform.length),e.defined(n.isFromGLP)&&(d+=1),this.packedLength=d+t.Ellipsoid.packedLength+h.VertexFormat.packedLength+2}C.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",C.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",C.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",C.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored",A.pack=function(n,o,i){let l;i=e.defaultValue(i,0);const s=n._positions;let d=s.length;for(o[i++]=d,l=0;l<d;++l,i+=a.Cartesian3.packedLength)a.Cartesian3.pack(s[l],o,i);const c=n._shape;for(d=c.length,o[i++]=d,l=0;l<d;++l,i+=r.Cartesian2.packedLength)r.Cartesian2.pack(c[l],o,i);t.Ellipsoid.pack(n._ellipsoid,o,i),i+=t.Ellipsoid.packedLength,h.VertexFormat.pack(n._vertexFormat,o,i),i+=h.VertexFormat.packedLength,o[i++]=n._cornerType,o[i++]=n._granularity;const p=n._rootTransform;return e.defined(p)&&(a.Matrix4.pack(p,o,i++),i+=15),e.defined(n._isFromGLP)&&(o[i++]=n._isFromGLP),o};const M=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),R=new h.VertexFormat,D={polylinePositions:void 0,shapePositions:void 0,ellipsoid:M,vertexFormat:R,cornerType:void 0,granularity:void 0};A.unpack=function(n,o,i){let l;o=e.defaultValue(o,0);let s=n[o++];const d=new Array(s);for(l=0;l<s;++l,o+=a.Cartesian3.packedLength)d[l]=a.Cartesian3.unpack(n,o);s=n[o++];const c=new Array(s);for(l=0;l<s;++l,o+=r.Cartesian2.packedLength)c[l]=r.Cartesian2.unpack(n,o);const p=t.Ellipsoid.unpack(n,o,M);o+=t.Ellipsoid.packedLength;const m=h.VertexFormat.unpack(n,o,R);o+=h.VertexFormat.packedLength;const u=n[o++],g=n[o++];var y,f=new a.Matrix4;return n.length>o&&(a.Matrix4.unpack(n,o++,f),o+=15),y=n.length>o?n[o++]:0,e.defined(i)?(i._positions=d,i._shape=c,i._ellipsoid=t.Ellipsoid.clone(p,i._ellipsoid),i._vertexFormat=h.VertexFormat.clone(m,i._vertexFormat),i._cornerType=u,i._granularity=g,i._rootTransform=f,i._isFromGLP=y,i):(D.polylinePositions=d,D.shapePositions=c,D.cornerType=u,D.granularity=g,D.rootTransform=f,D.isFromGLP=y,new A(D))};const B=new o.BoundingRectangle;return A.createGeometry=function(e){const t=e._positions,i=n.arrayRemoveDuplicates(t,a.Cartesian3.equalsEpsilon);let r=e._shape;if(r=s.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(r),i.length<2||r.length<3)return;y.PolygonPipeline.computeWindingOrder2D(r)===y.WindingOrder.CLOCKWISE&&r.reverse();const l=o.BoundingRectangle.fromPoints(r,B);return V(s.PolylineVolumeGeometryLibrary.computePositions(i,r,l,e,!0),r,l,e._vertexFormat,e._rootTransform,0,e._isFromGLP)},function(n,o){return e.defined(o)&&(n=A.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),A.createGeometry(n)}}));
