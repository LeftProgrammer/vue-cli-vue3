define(["./GeometryOffsetAttribute-8c5e10db","./arrayRemoveDuplicates-4bbe2c1f","./Transforms-51e2663f","./Matrix4-3b2c0630","./RuntimeError-8952249c","./ComponentDatatype-c4f4738c","./PolylineVolumeGeometryLibrary-e2c85c62","./CorridorGeometryLibrary-1dff5950","./defaultValue-81eec7ed","./Ellipsoid-119327cb","./GeometryAttribute-8f0cc508","./GeometryAttributes-32b29525","./IndexDatatype-266e701d","./Math-c2b1b304","./PolygonPipeline-ef9e08dd","./Matrix2-115e2170","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-6354c9aa","./AxisAlignedBoundingBox-ace5a411","./IntersectionTests-4511d2eb","./Plane-f0451b7c","./PolylinePipeline-cfd2c1cf","./EllipsoidGeodesic-52fe8ffa","./EllipsoidRhumbLine-6fa5d271"],(function(e,t,i,r,o,n,s,a,l,d,u,p,c,f,h,y,g,b,m,A,_,E,C,G,T,P){"use strict";const v=new r.Cartesian3,w=new r.Cartesian3,L=new r.Cartesian3;function D(e,t){const i=[],o=e.positions,d=e.corners,f=e.endPositions,h=new p.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<o.length;g+=2)b=o[g].length-3,m+=b,_+=b/3*4,A+=o[g+1].length-3;for(m+=3,A+=3,g=0;g<d.length;g++){y=d[g];const e=d[g].leftPositions;l.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=d[g].rightPositions.length,A+=b,_+=b/3*2)}const E=l.defined(f);let C;E&&(C=f[0].length-3,m+=C,A+=C,C/=3,_+=4*C);const G=m+A,T=new Float64Array(G);let P,D,x,k,V,H,N=0,O=G-1;const I=C/2,M=c.IndexDatatype.createTypedArray(G/3,_+4);let S=0;if(M[S++]=N/3,M[S++]=(O-2)/3,E){i.push(N/3),H=v,V=w;const e=f[0];for(g=0;g<I;g++)H=r.Cartesian3.fromArray(e,3*(I-1-g),H),V=r.Cartesian3.fromArray(e,3*(I+g),V),a.CorridorGeometryLibrary.addAttribute(T,V,N),a.CorridorGeometryLibrary.addAttribute(T,H,void 0,O),D=N/3,k=D+1,P=(O-2)/3,x=P-1,M[S++]=P,M[S++]=x,M[S++]=D,M[S++]=k,N+=3,O-=3}let B=0,R=o[B++],U=o[B++];for(T.set(R,N),T.set(U,O-U.length+1),b=U.length-3,i.push(N/3,(O-2)/3),g=0;g<b;g+=3)D=N/3,k=D+1,P=(O-2)/3,x=P-1,M[S++]=P,M[S++]=x,M[S++]=D,M[S++]=k,N+=3,O-=3;for(g=0;g<d.length;g++){let e;y=d[g];const n=y.leftPositions,u=y.rightPositions;let p,c=L;if(l.defined(n)){for(O-=3,p=x,i.push(k),e=0;e<n.length/3;e++)c=r.Cartesian3.fromArray(n,3*e,c),M[S++]=p-e-1,M[S++]=p-e,a.CorridorGeometryLibrary.addAttribute(T,c,void 0,O),O-=3;i.push(p-Math.floor(n.length/6)),t===s.CornerType.BEVELED&&i.push((O-2)/3+1),N+=3}else{for(N+=3,p=k,i.push(x),e=0;e<u.length/3;e++)c=r.Cartesian3.fromArray(u,3*e,c),M[S++]=p+e,M[S++]=p+e+1,a.CorridorGeometryLibrary.addAttribute(T,c,N),N+=3;i.push(p+Math.floor(u.length/6)),t===s.CornerType.BEVELED&&i.push(N/3-1),O-=3}for(R=o[B++],U=o[B++],R.splice(0,3),U.splice(U.length-3,3),T.set(R,N),T.set(U,O-U.length+1),b=U.length-3,e=0;e<U.length;e+=3)k=N/3,D=k-1,x=(O-2)/3,P=x+1,M[S++]=P,M[S++]=x,M[S++]=D,M[S++]=k,N+=3,O-=3;N-=3,O+=3,i.push(N/3,(O-2)/3)}if(E){N+=3,O-=3,H=v,V=w;const e=f[1];for(g=0;g<I;g++)H=r.Cartesian3.fromArray(e,3*(C-g-1),H),V=r.Cartesian3.fromArray(e,3*g,V),a.CorridorGeometryLibrary.addAttribute(T,H,void 0,O),a.CorridorGeometryLibrary.addAttribute(T,V,N),k=N/3,D=k-1,x=(O-2)/3,P=x+1,M[S++]=P,M[S++]=x,M[S++]=D,M[S++]=k,N+=3,O-=3;i.push(N/3)}else i.push(N/3,(O-2)/3);return M[S++]=N/3,M[S++]=(O-2)/3,h.position=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:T}),{attributes:h,indices:M,wallIndices:i}}function x(e){const t=(e=l.defaultValue(e,l.defaultValue.EMPTY_OBJECT)).positions,i=e.width,o=l.defaultValue(e.height,0),n=l.defaultValue(e.extrudedHeight,o);this._positions=t,this._ellipsoid=d.Ellipsoid.clone(l.defaultValue(e.ellipsoid,d.Ellipsoid.WGS84)),this._width=i,this._height=Math.max(o,n),this._extrudedHeight=Math.min(o,n),this._cornerType=l.defaultValue(e.cornerType,s.CornerType.ROUNDED),this._granularity=l.defaultValue(e.granularity,f.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*r.Cartesian3.packedLength+d.Ellipsoid.packedLength+6}x.pack=function(e,t,i){i=l.defaultValue(i,0);const o=e._positions,n=o.length;t[i++]=n;for(let e=0;e<n;++e,i+=r.Cartesian3.packedLength)r.Cartesian3.pack(o[e],t,i);return d.Ellipsoid.pack(e._ellipsoid,t,i),i+=d.Ellipsoid.packedLength,t[i++]=e._width,t[i++]=e._height,t[i++]=e._extrudedHeight,t[i++]=e._cornerType,t[i++]=e._granularity,t[i]=l.defaultValue(e._offsetAttribute,-1),t};const k=d.Ellipsoid.clone(d.Ellipsoid.UNIT_SPHERE),V={positions:void 0,ellipsoid:k,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return x.unpack=function(e,t,i){t=l.defaultValue(t,0);const o=e[t++],n=new Array(o);for(let i=0;i<o;++i,t+=r.Cartesian3.packedLength)n[i]=r.Cartesian3.unpack(e,t);const s=d.Ellipsoid.unpack(e,t,k);t+=d.Ellipsoid.packedLength;const a=e[t++],u=e[t++],p=e[t++],c=e[t++],f=e[t++],h=e[t];return l.defined(i)?(i._positions=n,i._ellipsoid=d.Ellipsoid.clone(s,i._ellipsoid),i._width=a,i._height=u,i._extrudedHeight=p,i._cornerType=c,i._granularity=f,i._offsetAttribute=-1===h?void 0:h,i):(V.positions=n,V.width=a,V.height=u,V.extrudedHeight=p,V.cornerType=c,V.granularity=f,V.offsetAttribute=-1===h?void 0:h,new x(V))},x.createGeometry=function(o){let s=o._positions;const d=o._width,p=o._ellipsoid;s=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(s,p);const y=t.arrayRemoveDuplicates(s,r.Cartesian3.equalsEpsilon);if(y.length<2||d<=0)return;const g=o._height,b=o._extrudedHeight,m=!f.CesiumMath.equalsEpsilon(g,b,0,f.CesiumMath.EPSILON2),A={ellipsoid:p,positions:y,width:d,cornerType:o._cornerType,granularity:o._granularity,saveAttributes:!1};let _;if(m)A.height=g,A.extrudedHeight=b,A.offsetAttribute=o._offsetAttribute,_=function(t){const i=t.ellipsoid,r=D(a.CorridorGeometryLibrary.computePositions(t),t.cornerType),o=r.wallIndices,s=t.height,d=t.extrudedHeight,p=r.attributes,f=r.indices;let y=p.position.values,g=y.length,b=new Float64Array(g);b.set(y);const m=new Float64Array(2*g);if(y=h.PolygonPipeline.scaleToGeodeticHeight(y,s,i),b=h.PolygonPipeline.scaleToGeodeticHeight(b,d,i),m.set(y),m.set(b,g),p.position.values=m,g/=3,l.defined(t.offsetAttribute)){let i=new Uint8Array(2*g);if(t.offsetAttribute===e.GeometryOffsetAttribute.TOP)i=e.arrayFill(i,1,0,g);else{const r=t.offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;i=e.arrayFill(i,r)}p.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}let A;const _=f.length,E=c.IndexDatatype.createTypedArray(m.length/3,2*(_+o.length));E.set(f);let C,G,T=_;for(A=0;A<_;A+=2){const e=f[A],t=f[A+1];E[T++]=e+g,E[T++]=t+g}for(A=0;A<o.length;A++)C=o[A],G=C+g,E[T++]=C,E[T++]=G;return{attributes:p,indices:E}}(A);else{if(_=D(a.CorridorGeometryLibrary.computePositions(A),A.cornerType),_.attributes.position.values=h.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,g,p),l.defined(o._offsetAttribute)){const t=_.attributes.position.values.length,i=new Uint8Array(t/3),r=o._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(i,r),_.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}const E=_.attributes,C=i.BoundingSphere.fromVertices(E.position.values,void 0,3);return new u.Geometry({attributes:E,indices:_.indices,primitiveType:u.PrimitiveType.LINES,boundingSphere:C,offsetAttribute:o._offsetAttribute})},function(e,t){return l.defined(t)&&(e=x.unpack(e,t)),e._ellipsoid=d.Ellipsoid.clone(e._ellipsoid),x.createGeometry(e)}}));
